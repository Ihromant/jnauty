// Generated by jextract

package ua.ihromant.jnauty.ffm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct TracesOptions {
 *     boolean getcanon;
 *     boolean writeautoms;
 *     boolean cartesian;
 *     boolean digraph;
 *     boolean defaultptn;
 *     int linelength;
 *     FILE *outfile;
 *     int strategy;
 *     int verbosity;
 *     permnode **generators;
 *     void (*userautomproc)(int, int *, int);
 *     void *reserved;
 *     boolean weighted;
 * }
 * }
 */
public class TracesOptions {

    TracesOptions() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        NautyTraces.C_INT.withName("getcanon"),
        NautyTraces.C_INT.withName("writeautoms"),
        NautyTraces.C_INT.withName("cartesian"),
        NautyTraces.C_INT.withName("digraph"),
        NautyTraces.C_INT.withName("defaultptn"),
        NautyTraces.C_INT.withName("linelength"),
        NautyTraces.C_POINTER.withName("outfile"),
        NautyTraces.C_INT.withName("strategy"),
        NautyTraces.C_INT.withName("verbosity"),
        NautyTraces.C_POINTER.withName("generators"),
        NautyTraces.C_POINTER.withName("userautomproc"),
        NautyTraces.C_POINTER.withName("reserved"),
        NautyTraces.C_INT.withName("weighted"),
        MemoryLayout.paddingLayout(4)
    ).withName("TracesOptions");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt getcanon$LAYOUT = (OfInt)$LAYOUT.select(groupElement("getcanon"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean getcanon
     * }
     */
    public static final OfInt getcanon$layout() {
        return getcanon$LAYOUT;
    }

    private static final long getcanon$OFFSET = $LAYOUT.byteOffset(groupElement("getcanon"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean getcanon
     * }
     */
    public static final long getcanon$offset() {
        return getcanon$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean getcanon
     * }
     */
    public static int getcanon(MemorySegment struct) {
        return struct.get(getcanon$LAYOUT, getcanon$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean getcanon
     * }
     */
    public static void getcanon(MemorySegment struct, int fieldValue) {
        struct.set(getcanon$LAYOUT, getcanon$OFFSET, fieldValue);
    }

    private static final OfInt writeautoms$LAYOUT = (OfInt)$LAYOUT.select(groupElement("writeautoms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static final OfInt writeautoms$layout() {
        return writeautoms$LAYOUT;
    }

    private static final long writeautoms$OFFSET = $LAYOUT.byteOffset(groupElement("writeautoms"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static final long writeautoms$offset() {
        return writeautoms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static int writeautoms(MemorySegment struct) {
        return struct.get(writeautoms$LAYOUT, writeautoms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static void writeautoms(MemorySegment struct, int fieldValue) {
        struct.set(writeautoms$LAYOUT, writeautoms$OFFSET, fieldValue);
    }

    private static final OfInt cartesian$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cartesian"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static final OfInt cartesian$layout() {
        return cartesian$LAYOUT;
    }

    private static final long cartesian$OFFSET = $LAYOUT.byteOffset(groupElement("cartesian"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static final long cartesian$offset() {
        return cartesian$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static int cartesian(MemorySegment struct) {
        return struct.get(cartesian$LAYOUT, cartesian$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static void cartesian(MemorySegment struct, int fieldValue) {
        struct.set(cartesian$LAYOUT, cartesian$OFFSET, fieldValue);
    }

    private static final OfInt digraph$LAYOUT = (OfInt)$LAYOUT.select(groupElement("digraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static final OfInt digraph$layout() {
        return digraph$LAYOUT;
    }

    private static final long digraph$OFFSET = $LAYOUT.byteOffset(groupElement("digraph"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static final long digraph$offset() {
        return digraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static int digraph(MemorySegment struct) {
        return struct.get(digraph$LAYOUT, digraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static void digraph(MemorySegment struct, int fieldValue) {
        struct.set(digraph$LAYOUT, digraph$OFFSET, fieldValue);
    }

    private static final OfInt defaultptn$LAYOUT = (OfInt)$LAYOUT.select(groupElement("defaultptn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static final OfInt defaultptn$layout() {
        return defaultptn$LAYOUT;
    }

    private static final long defaultptn$OFFSET = $LAYOUT.byteOffset(groupElement("defaultptn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static final long defaultptn$offset() {
        return defaultptn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static int defaultptn(MemorySegment struct) {
        return struct.get(defaultptn$LAYOUT, defaultptn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static void defaultptn(MemorySegment struct, int fieldValue) {
        struct.set(defaultptn$LAYOUT, defaultptn$OFFSET, fieldValue);
    }

    private static final OfInt linelength$LAYOUT = (OfInt)$LAYOUT.select(groupElement("linelength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static final OfInt linelength$layout() {
        return linelength$LAYOUT;
    }

    private static final long linelength$OFFSET = $LAYOUT.byteOffset(groupElement("linelength"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static final long linelength$offset() {
        return linelength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static int linelength(MemorySegment struct) {
        return struct.get(linelength$LAYOUT, linelength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static void linelength(MemorySegment struct, int fieldValue) {
        struct.set(linelength$LAYOUT, linelength$OFFSET, fieldValue);
    }

    private static final AddressLayout outfile$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("outfile"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static final AddressLayout outfile$layout() {
        return outfile$LAYOUT;
    }

    private static final long outfile$OFFSET = $LAYOUT.byteOffset(groupElement("outfile"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static final long outfile$offset() {
        return outfile$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static MemorySegment outfile(MemorySegment struct) {
        return struct.get(outfile$LAYOUT, outfile$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static void outfile(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(outfile$LAYOUT, outfile$OFFSET, fieldValue);
    }

    private static final OfInt strategy$LAYOUT = (OfInt)$LAYOUT.select(groupElement("strategy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int strategy
     * }
     */
    public static final OfInt strategy$layout() {
        return strategy$LAYOUT;
    }

    private static final long strategy$OFFSET = $LAYOUT.byteOffset(groupElement("strategy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int strategy
     * }
     */
    public static final long strategy$offset() {
        return strategy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int strategy
     * }
     */
    public static int strategy(MemorySegment struct) {
        return struct.get(strategy$LAYOUT, strategy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int strategy
     * }
     */
    public static void strategy(MemorySegment struct, int fieldValue) {
        struct.set(strategy$LAYOUT, strategy$OFFSET, fieldValue);
    }

    private static final OfInt verbosity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("verbosity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int verbosity
     * }
     */
    public static final OfInt verbosity$layout() {
        return verbosity$LAYOUT;
    }

    private static final long verbosity$OFFSET = $LAYOUT.byteOffset(groupElement("verbosity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int verbosity
     * }
     */
    public static final long verbosity$offset() {
        return verbosity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int verbosity
     * }
     */
    public static int verbosity(MemorySegment struct) {
        return struct.get(verbosity$LAYOUT, verbosity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int verbosity
     * }
     */
    public static void verbosity(MemorySegment struct, int fieldValue) {
        struct.set(verbosity$LAYOUT, verbosity$OFFSET, fieldValue);
    }

    private static final AddressLayout generators$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("generators"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * permnode **generators
     * }
     */
    public static final AddressLayout generators$layout() {
        return generators$LAYOUT;
    }

    private static final long generators$OFFSET = $LAYOUT.byteOffset(groupElement("generators"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * permnode **generators
     * }
     */
    public static final long generators$offset() {
        return generators$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * permnode **generators
     * }
     */
    public static MemorySegment generators(MemorySegment struct) {
        return struct.get(generators$LAYOUT, generators$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * permnode **generators
     * }
     */
    public static void generators(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(generators$LAYOUT, generators$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int)
     * }
     */
    public final static class userautomproc {

        private userautomproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(int _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout userautomproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userautomproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int)
     * }
     */
    public static final AddressLayout userautomproc$layout() {
        return userautomproc$LAYOUT;
    }

    private static final long userautomproc$OFFSET = $LAYOUT.byteOffset(groupElement("userautomproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int)
     * }
     */
    public static final long userautomproc$offset() {
        return userautomproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int)
     * }
     */
    public static MemorySegment userautomproc(MemorySegment struct) {
        return struct.get(userautomproc$LAYOUT, userautomproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int)
     * }
     */
    public static void userautomproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userautomproc$LAYOUT, userautomproc$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved
     * }
     */
    public static final AddressLayout reserved$layout() {
        return reserved$LAYOUT;
    }

    private static final long reserved$OFFSET = $LAYOUT.byteOffset(groupElement("reserved"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved
     * }
     */
    public static final long reserved$offset() {
        return reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved
     * }
     */
    public static MemorySegment reserved(MemorySegment struct) {
        return struct.get(reserved$LAYOUT, reserved$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved
     * }
     */
    public static void reserved(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved$LAYOUT, reserved$OFFSET, fieldValue);
    }

    private static final OfInt weighted$LAYOUT = (OfInt)$LAYOUT.select(groupElement("weighted"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean weighted
     * }
     */
    public static final OfInt weighted$layout() {
        return weighted$LAYOUT;
    }

    private static final long weighted$OFFSET = $LAYOUT.byteOffset(groupElement("weighted"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean weighted
     * }
     */
    public static final long weighted$offset() {
        return weighted$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean weighted
     * }
     */
    public static int weighted(MemorySegment struct) {
        return struct.get(weighted$LAYOUT, weighted$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean weighted
     * }
     */
    public static void weighted(MemorySegment struct, int fieldValue) {
        struct.set(weighted$LAYOUT, weighted$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

