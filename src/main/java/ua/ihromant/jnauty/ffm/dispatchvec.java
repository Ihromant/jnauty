// Generated by jextract

package ua.ihromant.jnauty.ffm;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SegmentAllocator;
import java.lang.invoke.MethodHandle;
import java.util.function.Consumer;

import static java.lang.foreign.MemoryLayout.PathElement.groupElement;

/**
 * {@snippet lang=c :
 * struct {
 *     boolean (*isautom)(graph *, int *, boolean, int, int);
 *     int (*testcanlab)(graph *, graph *, int *, int *, int, int);
 *     void (*updatecan)(graph *, graph *, int *, int, int, int);
 *     void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int);
 *     void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int);
 *     boolean (*cheapautom)(int *, int, boolean, int);
 *     int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int);
 *     void (*freedyn)(void);
 *     void (*check)(int, int, int, int);
 *     void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int);
 *     void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int);
 * }
 * }
 */
public class dispatchvec {

    dispatchvec() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        nautinv_h.C_POINTER.withName("isautom"),
        nautinv_h.C_POINTER.withName("testcanlab"),
        nautinv_h.C_POINTER.withName("updatecan"),
        nautinv_h.C_POINTER.withName("refine"),
        nautinv_h.C_POINTER.withName("refine1"),
        nautinv_h.C_POINTER.withName("cheapautom"),
        nautinv_h.C_POINTER.withName("targetcell"),
        nautinv_h.C_POINTER.withName("freedyn"),
        nautinv_h.C_POINTER.withName("check"),
        nautinv_h.C_POINTER.withName("init"),
        nautinv_h.C_POINTER.withName("cleanup")
    ).withName("$anon$1151:9");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * boolean (*isautom)(graph *, int *, boolean, int, int)
     * }
     */
    public final static class isautom {

        private isautom() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout isautom$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("isautom"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean (*isautom)(graph *, int *, boolean, int, int)
     * }
     */
    public static final AddressLayout isautom$layout() {
        return isautom$LAYOUT;
    }

    private static final long isautom$OFFSET = $LAYOUT.byteOffset(groupElement("isautom"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean (*isautom)(graph *, int *, boolean, int, int)
     * }
     */
    public static final long isautom$offset() {
        return isautom$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean (*isautom)(graph *, int *, boolean, int, int)
     * }
     */
    public static MemorySegment isautom(MemorySegment struct) {
        return struct.get(isautom$LAYOUT, isautom$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean (*isautom)(graph *, int *, boolean, int, int)
     * }
     */
    public static void isautom(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(isautom$LAYOUT, isautom$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*testcanlab)(graph *, graph *, int *, int *, int, int)
     * }
     */
    public final static class testcanlab {

        private testcanlab() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout testcanlab$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("testcanlab"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*testcanlab)(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static final AddressLayout testcanlab$layout() {
        return testcanlab$LAYOUT;
    }

    private static final long testcanlab$OFFSET = $LAYOUT.byteOffset(groupElement("testcanlab"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*testcanlab)(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static final long testcanlab$offset() {
        return testcanlab$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*testcanlab)(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MemorySegment testcanlab(MemorySegment struct) {
        return struct.get(testcanlab$LAYOUT, testcanlab$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*testcanlab)(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static void testcanlab(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(testcanlab$LAYOUT, testcanlab$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*updatecan)(graph *, graph *, int *, int, int, int)
     * }
     */
    public final static class updatecan {

        private updatecan() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout updatecan$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("updatecan"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*updatecan)(graph *, graph *, int *, int, int, int)
     * }
     */
    public static final AddressLayout updatecan$layout() {
        return updatecan$LAYOUT;
    }

    private static final long updatecan$OFFSET = $LAYOUT.byteOffset(groupElement("updatecan"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*updatecan)(graph *, graph *, int *, int, int, int)
     * }
     */
    public static final long updatecan$offset() {
        return updatecan$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*updatecan)(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MemorySegment updatecan(MemorySegment struct) {
        return struct.get(updatecan$LAYOUT, updatecan$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*updatecan)(graph *, graph *, int *, int, int, int)
     * }
     */
    public static void updatecan(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(updatecan$LAYOUT, updatecan$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public final static class refine {

        private refine() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout refine$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("refine"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final AddressLayout refine$layout() {
        return refine$LAYOUT;
    }

    private static final long refine$OFFSET = $LAYOUT.byteOffset(groupElement("refine"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final long refine$offset() {
        return refine$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine(MemorySegment struct) {
        return struct.get(refine$LAYOUT, refine$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*refine)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(refine$LAYOUT, refine$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public final static class refine1 {

        private refine1() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout refine1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("refine1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final AddressLayout refine1$layout() {
        return refine1$LAYOUT;
    }

    private static final long refine1$OFFSET = $LAYOUT.byteOffset(groupElement("refine1"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final long refine1$offset() {
        return refine1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine1(MemorySegment struct) {
        return struct.get(refine1$LAYOUT, refine1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*refine1)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(refine1$LAYOUT, refine1$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * boolean (*cheapautom)(int *, int, boolean, int)
     * }
     */
    public final static class cheapautom {

        private cheapautom() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cheapautom$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cheapautom"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean (*cheapautom)(int *, int, boolean, int)
     * }
     */
    public static final AddressLayout cheapautom$layout() {
        return cheapautom$LAYOUT;
    }

    private static final long cheapautom$OFFSET = $LAYOUT.byteOffset(groupElement("cheapautom"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean (*cheapautom)(int *, int, boolean, int)
     * }
     */
    public static final long cheapautom$offset() {
        return cheapautom$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean (*cheapautom)(int *, int, boolean, int)
     * }
     */
    public static MemorySegment cheapautom(MemorySegment struct) {
        return struct.get(cheapautom$LAYOUT, cheapautom$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean (*cheapautom)(int *, int, boolean, int)
     * }
     */
    public static void cheapautom(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cheapautom$LAYOUT, cheapautom$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public final static class targetcell {

        private targetcell() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, int _x6, int _x7, int _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, int _x6, int _x7, int _x8) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout targetcell$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("targetcell"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static final AddressLayout targetcell$layout() {
        return targetcell$LAYOUT;
    }

    private static final long targetcell$OFFSET = $LAYOUT.byteOffset(groupElement("targetcell"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static final long targetcell$offset() {
        return targetcell$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MemorySegment targetcell(MemorySegment struct) {
        return struct.get(targetcell$LAYOUT, targetcell$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*targetcell)(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static void targetcell(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(targetcell$LAYOUT, targetcell$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*freedyn)(void)
     * }
     */
    public final static class freedyn {

        private freedyn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout freedyn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("freedyn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*freedyn)(void)
     * }
     */
    public static final AddressLayout freedyn$layout() {
        return freedyn$LAYOUT;
    }

    private static final long freedyn$OFFSET = $LAYOUT.byteOffset(groupElement("freedyn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*freedyn)(void)
     * }
     */
    public static final long freedyn$offset() {
        return freedyn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*freedyn)(void)
     * }
     */
    public static MemorySegment freedyn(MemorySegment struct) {
        return struct.get(freedyn$LAYOUT, freedyn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*freedyn)(void)
     * }
     */
    public static void freedyn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(freedyn$LAYOUT, freedyn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*check)(int, int, int, int)
     * }
     */
    public final static class check {

        private check() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(int _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, int _x0, int _x1, int _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout check$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("check"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*check)(int, int, int, int)
     * }
     */
    public static final AddressLayout check$layout() {
        return check$LAYOUT;
    }

    private static final long check$OFFSET = $LAYOUT.byteOffset(groupElement("check"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*check)(int, int, int, int)
     * }
     */
    public static final long check$offset() {
        return check$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*check)(int, int, int, int)
     * }
     */
    public static MemorySegment check(MemorySegment struct) {
        return struct.get(check$LAYOUT, check$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*check)(int, int, int, int)
     * }
     */
    public static void check(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(check$LAYOUT, check$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public final static class init {

        private init() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8, int _x9, int _x10);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8, int _x9, int _x10) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout init$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("init"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static final AddressLayout init$layout() {
        return init$LAYOUT;
    }

    private static final long init$OFFSET = $LAYOUT.byteOffset(groupElement("init"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static final long init$offset() {
        return init$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static MemorySegment init(MemorySegment struct) {
        return struct.get(init$LAYOUT, init$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*init)(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static void init(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(init$LAYOUT, init$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int)
     * }
     */
    public final static class cleanup {

        private cleanup() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = nautinv_h.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cleanup$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cleanup"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int)
     * }
     */
    public static final AddressLayout cleanup$layout() {
        return cleanup$LAYOUT;
    }

    private static final long cleanup$OFFSET = $LAYOUT.byteOffset(groupElement("cleanup"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int)
     * }
     */
    public static final long cleanup$offset() {
        return cleanup$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int)
     * }
     */
    public static MemorySegment cleanup(MemorySegment struct) {
        return struct.get(cleanup$LAYOUT, cleanup$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*cleanup)(graph *, graph **, graph *, graph **, int *, int *, struct optionstruct *, statsblk *, int, int)
     * }
     */
    public static void cleanup(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cleanup$LAYOUT, cleanup$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

