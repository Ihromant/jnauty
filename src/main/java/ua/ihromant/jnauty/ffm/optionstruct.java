// Generated by jextract

package ua.ihromant.jnauty.ffm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct optionstruct {
 *     int getcanon;
 *     boolean digraph;
 *     boolean writeautoms;
 *     boolean writemarkers;
 *     boolean defaultptn;
 *     boolean cartesian;
 *     int linelength;
 *     FILE *outfile;
 *     void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int);
 *     void (*userautomproc)(int, int *, int *, int, int, int);
 *     void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int);
 *     void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int);
 *     int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int);
 *     void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int);
 *     int tc_level;
 *     int mininvarlevel;
 *     int maxinvarlevel;
 *     int invararg;
 *     dispatchvec *dispatch;
 *     boolean schreier;
 *     void *extra_options;
 * }
 * }
 */
public class optionstruct {

    optionstruct() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        NautyTraces.C_INT.withName("getcanon"),
        NautyTraces.C_INT.withName("digraph"),
        NautyTraces.C_INT.withName("writeautoms"),
        NautyTraces.C_INT.withName("writemarkers"),
        NautyTraces.C_INT.withName("defaultptn"),
        NautyTraces.C_INT.withName("cartesian"),
        NautyTraces.C_INT.withName("linelength"),
        MemoryLayout.paddingLayout(4),
        NautyTraces.C_POINTER.withName("outfile"),
        NautyTraces.C_POINTER.withName("userrefproc"),
        NautyTraces.C_POINTER.withName("userautomproc"),
        NautyTraces.C_POINTER.withName("userlevelproc"),
        NautyTraces.C_POINTER.withName("usernodeproc"),
        NautyTraces.C_POINTER.withName("usercanonproc"),
        NautyTraces.C_POINTER.withName("invarproc"),
        NautyTraces.C_INT.withName("tc_level"),
        NautyTraces.C_INT.withName("mininvarlevel"),
        NautyTraces.C_INT.withName("maxinvarlevel"),
        NautyTraces.C_INT.withName("invararg"),
        NautyTraces.C_POINTER.withName("dispatch"),
        NautyTraces.C_INT.withName("schreier"),
        MemoryLayout.paddingLayout(4),
        NautyTraces.C_POINTER.withName("extra_options")
    ).withName("optionstruct");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt getcanon$LAYOUT = (OfInt)$LAYOUT.select(groupElement("getcanon"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int getcanon
     * }
     */
    public static final OfInt getcanon$layout() {
        return getcanon$LAYOUT;
    }

    private static final long getcanon$OFFSET = $LAYOUT.byteOffset(groupElement("getcanon"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int getcanon
     * }
     */
    public static final long getcanon$offset() {
        return getcanon$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int getcanon
     * }
     */
    public static int getcanon(MemorySegment struct) {
        return struct.get(getcanon$LAYOUT, getcanon$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int getcanon
     * }
     */
    public static void getcanon(MemorySegment struct, int fieldValue) {
        struct.set(getcanon$LAYOUT, getcanon$OFFSET, fieldValue);
    }

    private static final OfInt digraph$LAYOUT = (OfInt)$LAYOUT.select(groupElement("digraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static final OfInt digraph$layout() {
        return digraph$LAYOUT;
    }

    private static final long digraph$OFFSET = $LAYOUT.byteOffset(groupElement("digraph"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static final long digraph$offset() {
        return digraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static int digraph(MemorySegment struct) {
        return struct.get(digraph$LAYOUT, digraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean digraph
     * }
     */
    public static void digraph(MemorySegment struct, int fieldValue) {
        struct.set(digraph$LAYOUT, digraph$OFFSET, fieldValue);
    }

    private static final OfInt writeautoms$LAYOUT = (OfInt)$LAYOUT.select(groupElement("writeautoms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static final OfInt writeautoms$layout() {
        return writeautoms$LAYOUT;
    }

    private static final long writeautoms$OFFSET = $LAYOUT.byteOffset(groupElement("writeautoms"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static final long writeautoms$offset() {
        return writeautoms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static int writeautoms(MemorySegment struct) {
        return struct.get(writeautoms$LAYOUT, writeautoms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean writeautoms
     * }
     */
    public static void writeautoms(MemorySegment struct, int fieldValue) {
        struct.set(writeautoms$LAYOUT, writeautoms$OFFSET, fieldValue);
    }

    private static final OfInt writemarkers$LAYOUT = (OfInt)$LAYOUT.select(groupElement("writemarkers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean writemarkers
     * }
     */
    public static final OfInt writemarkers$layout() {
        return writemarkers$LAYOUT;
    }

    private static final long writemarkers$OFFSET = $LAYOUT.byteOffset(groupElement("writemarkers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean writemarkers
     * }
     */
    public static final long writemarkers$offset() {
        return writemarkers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean writemarkers
     * }
     */
    public static int writemarkers(MemorySegment struct) {
        return struct.get(writemarkers$LAYOUT, writemarkers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean writemarkers
     * }
     */
    public static void writemarkers(MemorySegment struct, int fieldValue) {
        struct.set(writemarkers$LAYOUT, writemarkers$OFFSET, fieldValue);
    }

    private static final OfInt defaultptn$LAYOUT = (OfInt)$LAYOUT.select(groupElement("defaultptn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static final OfInt defaultptn$layout() {
        return defaultptn$LAYOUT;
    }

    private static final long defaultptn$OFFSET = $LAYOUT.byteOffset(groupElement("defaultptn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static final long defaultptn$offset() {
        return defaultptn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static int defaultptn(MemorySegment struct) {
        return struct.get(defaultptn$LAYOUT, defaultptn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean defaultptn
     * }
     */
    public static void defaultptn(MemorySegment struct, int fieldValue) {
        struct.set(defaultptn$LAYOUT, defaultptn$OFFSET, fieldValue);
    }

    private static final OfInt cartesian$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cartesian"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static final OfInt cartesian$layout() {
        return cartesian$LAYOUT;
    }

    private static final long cartesian$OFFSET = $LAYOUT.byteOffset(groupElement("cartesian"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static final long cartesian$offset() {
        return cartesian$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static int cartesian(MemorySegment struct) {
        return struct.get(cartesian$LAYOUT, cartesian$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean cartesian
     * }
     */
    public static void cartesian(MemorySegment struct, int fieldValue) {
        struct.set(cartesian$LAYOUT, cartesian$OFFSET, fieldValue);
    }

    private static final OfInt linelength$LAYOUT = (OfInt)$LAYOUT.select(groupElement("linelength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static final OfInt linelength$layout() {
        return linelength$LAYOUT;
    }

    private static final long linelength$OFFSET = $LAYOUT.byteOffset(groupElement("linelength"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static final long linelength$offset() {
        return linelength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static int linelength(MemorySegment struct) {
        return struct.get(linelength$LAYOUT, linelength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int linelength
     * }
     */
    public static void linelength(MemorySegment struct, int fieldValue) {
        struct.set(linelength$LAYOUT, linelength$OFFSET, fieldValue);
    }

    private static final AddressLayout outfile$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("outfile"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static final AddressLayout outfile$layout() {
        return outfile$LAYOUT;
    }

    private static final long outfile$OFFSET = $LAYOUT.byteOffset(groupElement("outfile"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static final long outfile$offset() {
        return outfile$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static MemorySegment outfile(MemorySegment struct) {
        return struct.get(outfile$LAYOUT, outfile$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FILE *outfile
     * }
     */
    public static void outfile(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(outfile$LAYOUT, outfile$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public final static class userrefproc {

        private userrefproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, int _x8, int _x9) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout userrefproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userrefproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final AddressLayout userrefproc$layout() {
        return userrefproc$LAYOUT;
    }

    private static final long userrefproc$OFFSET = $LAYOUT.byteOffset(groupElement("userrefproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static final long userrefproc$offset() {
        return userrefproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment userrefproc(MemorySegment struct) {
        return struct.get(userrefproc$LAYOUT, userrefproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*userrefproc)(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void userrefproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userrefproc$LAYOUT, userrefproc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int *, int, int, int)
     * }
     */
    public final static class userautomproc {

        private userautomproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(int _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout userautomproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userautomproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int *, int, int, int)
     * }
     */
    public static final AddressLayout userautomproc$layout() {
        return userautomproc$LAYOUT;
    }

    private static final long userautomproc$OFFSET = $LAYOUT.byteOffset(groupElement("userautomproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int *, int, int, int)
     * }
     */
    public static final long userautomproc$offset() {
        return userautomproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int *, int, int, int)
     * }
     */
    public static MemorySegment userautomproc(MemorySegment struct) {
        return struct.get(userautomproc$LAYOUT, userautomproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*userautomproc)(int, int *, int *, int, int, int)
     * }
     */
    public static void userautomproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userautomproc$LAYOUT, userautomproc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int)
     * }
     */
    public final static class userlevelproc {

        private userlevelproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, int _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, int _x5, int _x6, int _x7, int _x8, int _x9, int _x10) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout userlevelproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userlevelproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int)
     * }
     */
    public static final AddressLayout userlevelproc$layout() {
        return userlevelproc$LAYOUT;
    }

    private static final long userlevelproc$OFFSET = $LAYOUT.byteOffset(groupElement("userlevelproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int)
     * }
     */
    public static final long userlevelproc$offset() {
        return userlevelproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int)
     * }
     */
    public static MemorySegment userlevelproc(MemorySegment struct) {
        return struct.get(userlevelproc$LAYOUT, userlevelproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*userlevelproc)(int *, int *, int, int *, statsblk *, int, int, int, int, int, int)
     * }
     */
    public static void userlevelproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userlevelproc$LAYOUT, userlevelproc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int)
     * }
     */
    public final static class usernodeproc {

        private usernodeproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, int _x6, int _x7, int _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, int _x6, int _x7, int _x8) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout usernodeproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("usernodeproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static final AddressLayout usernodeproc$layout() {
        return usernodeproc$LAYOUT;
    }

    private static final long usernodeproc$OFFSET = $LAYOUT.byteOffset(groupElement("usernodeproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static final long usernodeproc$offset() {
        return usernodeproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static MemorySegment usernodeproc(MemorySegment struct) {
        return struct.get(usernodeproc$LAYOUT, usernodeproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*usernodeproc)(graph *, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static void usernodeproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(usernodeproc$LAYOUT, usernodeproc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int)
     * }
     */
    public final static class usercanonproc {

        private usercanonproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, int _x4, int _x5, int _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, int _x4, int _x5, int _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout usercanonproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("usercanonproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int)
     * }
     */
    public static final AddressLayout usercanonproc$layout() {
        return usercanonproc$LAYOUT;
    }

    private static final long usercanonproc$OFFSET = $LAYOUT.byteOffset(groupElement("usercanonproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int)
     * }
     */
    public static final long usercanonproc$offset() {
        return usercanonproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int)
     * }
     */
    public static MemorySegment usercanonproc(MemorySegment struct) {
        return struct.get(usercanonproc$LAYOUT, usercanonproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*usercanonproc)(graph *, int *, graph *, unsigned long, int, int, int)
     * }
     */
    public static void usercanonproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(usercanonproc$LAYOUT, usercanonproc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public final static class invarproc {

        private invarproc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, MemorySegment _x6, int _x7, int _x8, int _x9, int _x10);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = NautyTraces.upcallHandle(Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, int _x5, MemorySegment _x6, int _x7, int _x8, int _x9, int _x10) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout invarproc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("invarproc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static final AddressLayout invarproc$layout() {
        return invarproc$LAYOUT;
    }

    private static final long invarproc$OFFSET = $LAYOUT.byteOffset(groupElement("invarproc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static final long invarproc$offset() {
        return invarproc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment invarproc(MemorySegment struct) {
        return struct.get(invarproc$LAYOUT, invarproc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*invarproc)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void invarproc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(invarproc$LAYOUT, invarproc$OFFSET, fieldValue);
    }

    private static final OfInt tc_level$LAYOUT = (OfInt)$LAYOUT.select(groupElement("tc_level"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int tc_level
     * }
     */
    public static final OfInt tc_level$layout() {
        return tc_level$LAYOUT;
    }

    private static final long tc_level$OFFSET = $LAYOUT.byteOffset(groupElement("tc_level"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int tc_level
     * }
     */
    public static final long tc_level$offset() {
        return tc_level$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int tc_level
     * }
     */
    public static int tc_level(MemorySegment struct) {
        return struct.get(tc_level$LAYOUT, tc_level$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int tc_level
     * }
     */
    public static void tc_level(MemorySegment struct, int fieldValue) {
        struct.set(tc_level$LAYOUT, tc_level$OFFSET, fieldValue);
    }

    private static final OfInt mininvarlevel$LAYOUT = (OfInt)$LAYOUT.select(groupElement("mininvarlevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int mininvarlevel
     * }
     */
    public static final OfInt mininvarlevel$layout() {
        return mininvarlevel$LAYOUT;
    }

    private static final long mininvarlevel$OFFSET = $LAYOUT.byteOffset(groupElement("mininvarlevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int mininvarlevel
     * }
     */
    public static final long mininvarlevel$offset() {
        return mininvarlevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int mininvarlevel
     * }
     */
    public static int mininvarlevel(MemorySegment struct) {
        return struct.get(mininvarlevel$LAYOUT, mininvarlevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int mininvarlevel
     * }
     */
    public static void mininvarlevel(MemorySegment struct, int fieldValue) {
        struct.set(mininvarlevel$LAYOUT, mininvarlevel$OFFSET, fieldValue);
    }

    private static final OfInt maxinvarlevel$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxinvarlevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxinvarlevel
     * }
     */
    public static final OfInt maxinvarlevel$layout() {
        return maxinvarlevel$LAYOUT;
    }

    private static final long maxinvarlevel$OFFSET = $LAYOUT.byteOffset(groupElement("maxinvarlevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxinvarlevel
     * }
     */
    public static final long maxinvarlevel$offset() {
        return maxinvarlevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxinvarlevel
     * }
     */
    public static int maxinvarlevel(MemorySegment struct) {
        return struct.get(maxinvarlevel$LAYOUT, maxinvarlevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxinvarlevel
     * }
     */
    public static void maxinvarlevel(MemorySegment struct, int fieldValue) {
        struct.set(maxinvarlevel$LAYOUT, maxinvarlevel$OFFSET, fieldValue);
    }

    private static final OfInt invararg$LAYOUT = (OfInt)$LAYOUT.select(groupElement("invararg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int invararg
     * }
     */
    public static final OfInt invararg$layout() {
        return invararg$LAYOUT;
    }

    private static final long invararg$OFFSET = $LAYOUT.byteOffset(groupElement("invararg"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int invararg
     * }
     */
    public static final long invararg$offset() {
        return invararg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int invararg
     * }
     */
    public static int invararg(MemorySegment struct) {
        return struct.get(invararg$LAYOUT, invararg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int invararg
     * }
     */
    public static void invararg(MemorySegment struct, int fieldValue) {
        struct.set(invararg$LAYOUT, invararg$OFFSET, fieldValue);
    }

    private static final AddressLayout dispatch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dispatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * dispatchvec *dispatch
     * }
     */
    public static final AddressLayout dispatch$layout() {
        return dispatch$LAYOUT;
    }

    private static final long dispatch$OFFSET = $LAYOUT.byteOffset(groupElement("dispatch"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * dispatchvec *dispatch
     * }
     */
    public static final long dispatch$offset() {
        return dispatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * dispatchvec *dispatch
     * }
     */
    public static MemorySegment dispatch(MemorySegment struct) {
        return struct.get(dispatch$LAYOUT, dispatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * dispatchvec *dispatch
     * }
     */
    public static void dispatch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dispatch$LAYOUT, dispatch$OFFSET, fieldValue);
    }

    private static final OfInt schreier$LAYOUT = (OfInt)$LAYOUT.select(groupElement("schreier"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean schreier
     * }
     */
    public static final OfInt schreier$layout() {
        return schreier$LAYOUT;
    }

    private static final long schreier$OFFSET = $LAYOUT.byteOffset(groupElement("schreier"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean schreier
     * }
     */
    public static final long schreier$offset() {
        return schreier$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean schreier
     * }
     */
    public static int schreier(MemorySegment struct) {
        return struct.get(schreier$LAYOUT, schreier$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean schreier
     * }
     */
    public static void schreier(MemorySegment struct, int fieldValue) {
        struct.set(schreier$LAYOUT, schreier$OFFSET, fieldValue);
    }

    private static final AddressLayout extra_options$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("extra_options"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *extra_options
     * }
     */
    public static final AddressLayout extra_options$layout() {
        return extra_options$LAYOUT;
    }

    private static final long extra_options$OFFSET = $LAYOUT.byteOffset(groupElement("extra_options"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *extra_options
     * }
     */
    public static final long extra_options$offset() {
        return extra_options$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *extra_options
     * }
     */
    public static MemorySegment extra_options(MemorySegment struct) {
        return struct.get(extra_options$LAYOUT, extra_options$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *extra_options
     * }
     */
    public static void extra_options(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(extra_options$LAYOUT, extra_options$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

