// Generated by jextract

package ua.ihromant.jnauty.ffm;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SegmentAllocator;
import java.lang.invoke.MethodHandle;

import static java.lang.foreign.ValueLayout.*;

public class nautinv_h extends nautinv_h_1 {

    nautinv_h() {
        // Should not be called directly
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG,
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG,
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG_LONG,
            nautinv_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            nautinv_h.C_LONG,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            nautinv_h.C_LONG_LONG,
            nautinv_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = nautinv_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = nautinv_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = nautinv_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = nautinv_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = nautinv_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = nautinv_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = nautinv_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = nautinv_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = nautinv_h.C_LONG;

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = nautinv_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = nautinv_h.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy$address() {
        return __mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy$address() {
        return mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_LONG,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long setword
     * }
     */
    public static final OfLong setword = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long nauty_counter
     * }
     */
    public static final OfLong nauty_counter = nautinv_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int shortish
     * }
     */
    public static final OfInt shortish = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int permutation
     * }
     */
    public static final OfInt permutation = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int nvector
     * }
     */
    public static final OfInt nvector = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int np2vector
     * }
     */
    public static final OfInt np2vector = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int boolean
     * }
     */
    public static final OfInt boolean_ = nautinv_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef setword set
     * }
     */
    public static final OfLong set = nautinv_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef setword graph
     * }
     */
    public static final OfLong graph = nautinv_h.C_LONG;

    private static class alloc_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloc_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static FunctionDescriptor alloc_error$descriptor() {
        return alloc_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static MethodHandle alloc_error$handle() {
        return alloc_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static MemorySegment alloc_error$address() {
        return alloc_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static void alloc_error(MemorySegment x0) {
        var mh$ = alloc_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloc_error", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class breakout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("breakout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static FunctionDescriptor breakout$descriptor() {
        return breakout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static MethodHandle breakout$handle() {
        return breakout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static MemorySegment breakout$address() {
        return breakout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static void breakout(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, MemorySegment x5, int x6) {
        var mh$ = breakout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("breakout", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheapautom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cheapautom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static FunctionDescriptor cheapautom$descriptor() {
        return cheapautom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static MethodHandle cheapautom$handle() {
        return cheapautom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static MemorySegment cheapautom$address() {
        return cheapautom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static int cheapautom(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = cheapautom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheapautom", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class doref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("doref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor doref$descriptor() {
        return doref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static MethodHandle doref$handle() {
        return doref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static MemorySegment doref$address() {
        return doref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static void doref(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, int x11, int x12, int x13, int x14, int x15, int x16) {
        var mh$ = doref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("doref", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class extra_autom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("extra_autom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static FunctionDescriptor extra_autom$descriptor() {
        return extra_autom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static MethodHandle extra_autom$handle() {
        return extra_autom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static MemorySegment extra_autom$address() {
        return extra_autom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static void extra_autom(MemorySegment x0, int x1) {
        var mh$ = extra_autom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("extra_autom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class extra_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("extra_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static FunctionDescriptor extra_level$descriptor() {
        return extra_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static MethodHandle extra_level$handle() {
        return extra_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static MemorySegment extra_level$address() {
        return extra_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static void extra_level(int x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, int x6, int x7, int x8) {
        var mh$ = extra_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("extra_level", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isautom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isautom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static FunctionDescriptor isautom$descriptor() {
        return isautom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static MethodHandle isautom$handle() {
        return isautom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static MemorySegment isautom$address() {
        return isautom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static int isautom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = isautom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isautom", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_graph$constants {
        public static final GroupLayout LAYOUT = dispatchvec.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("dispatch_graph").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static GroupLayout dispatch_graph$layout() {
        return dispatch_graph$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static MemorySegment dispatch_graph() {
        return dispatch_graph$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static void dispatch_graph(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, dispatch_graph$constants.SEGMENT, 0L, dispatch_graph$constants.LAYOUT.byteSize());
    }

    private static class itos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("itos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static FunctionDescriptor itos$descriptor() {
        return itos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static MethodHandle itos$handle() {
        return itos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static MemorySegment itos$address() {
        return itos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static int itos(int x0, MemorySegment x1) {
        var mh$ = itos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static FunctionDescriptor fmperm$descriptor() {
        return fmperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static MethodHandle fmperm$handle() {
        return fmperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static MemorySegment fmperm$address() {
        return fmperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static void fmperm(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4) {
        var mh$ = fmperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmperm", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static FunctionDescriptor fmptn$descriptor() {
        return fmptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static MethodHandle fmptn$handle() {
        return fmptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static MemorySegment fmptn$address() {
        return fmptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static void fmptn(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, int x5, int x6) {
        var mh$ = fmptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmptn", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class longprune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("longprune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static FunctionDescriptor longprune$descriptor() {
        return longprune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static MethodHandle longprune$handle() {
        return longprune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static MemorySegment longprune$address() {
        return longprune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static void longprune(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4) {
        var mh$ = longprune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("longprune", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static FunctionDescriptor nauty$descriptor() {
        return nauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static MethodHandle nauty$handle() {
        return nauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static MemorySegment nauty$address() {
        return nauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static void nauty(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9, int x10, MemorySegment x11) {
        var mh$ = nauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class maketargetcell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("maketargetcell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static FunctionDescriptor maketargetcell$descriptor() {
        return maketargetcell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static MethodHandle maketargetcell$handle() {
        return maketargetcell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static MemorySegment maketargetcell$address() {
        return maketargetcell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static void maketargetcell(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7, int x8, int x9, MemorySegment x10, int x11, int x12) {
        var mh$ = maketargetcell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("maketargetcell", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextelement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextelement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static FunctionDescriptor nextelement$descriptor() {
        return nextelement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static MethodHandle nextelement$handle() {
        return nextelement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static MemorySegment nextelement$address() {
        return nextelement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static int nextelement(MemorySegment x0, int x1, int x2) {
        var mh$ = nextelement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextelement", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class orbjoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("orbjoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static FunctionDescriptor orbjoin$descriptor() {
        return orbjoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static MethodHandle orbjoin$handle() {
        return orbjoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static MemorySegment orbjoin$address() {
        return orbjoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static int orbjoin(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = orbjoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("orbjoin", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class permset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("permset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static FunctionDescriptor permset$descriptor() {
        return permset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static MethodHandle permset$handle() {
        return permset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static MemorySegment permset$address() {
        return permset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static void permset(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = permset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("permset", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static FunctionDescriptor putstring$descriptor() {
        return putstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static MethodHandle putstring$handle() {
        return putstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static MemorySegment putstring$address() {
        return putstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static void putstring(MemorySegment x0, MemorySegment x1) {
        var mh$ = putstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putstring", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static FunctionDescriptor refine$descriptor() {
        return refine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MethodHandle refine$handle() {
        return refine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine$address() {
        return refine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9) {
        var mh$ = refine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static FunctionDescriptor refine1$descriptor() {
        return refine1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MethodHandle refine1$handle() {
        return refine1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine1$address() {
        return refine1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine1(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9) {
        var mh$ = refine1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine1", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shortprune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("shortprune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static FunctionDescriptor shortprune$descriptor() {
        return shortprune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static MethodHandle shortprune$handle() {
        return shortprune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static MemorySegment shortprune$address() {
        return shortprune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static void shortprune(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = shortprune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shortprune", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class targetcell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("targetcell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor targetcell$descriptor() {
        return targetcell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MethodHandle targetcell$handle() {
        return targetcell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MemorySegment targetcell$address() {
        return targetcell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static int targetcell(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, int x6, int x7, int x8) {
        var mh$ = targetcell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("targetcell", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class testcanlab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("testcanlab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor testcanlab$descriptor() {
        return testcanlab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MethodHandle testcanlab$handle() {
        return testcanlab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MemorySegment testcanlab$address() {
        return testcanlab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static int testcanlab(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = testcanlab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("testcanlab", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class updatecan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("updatecan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static FunctionDescriptor updatecan$descriptor() {
        return updatecan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MethodHandle updatecan$handle() {
        return updatecan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MemorySegment updatecan$address() {
        return updatecan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static void updatecan(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = updatecan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("updatecan", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static FunctionDescriptor writeperm$descriptor() {
        return writeperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static MethodHandle writeperm$handle() {
        return writeperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static MemorySegment writeperm$address() {
        return writeperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static void writeperm(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = writeperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeperm", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static FunctionDescriptor nauty_freedyn$descriptor() {
        return nauty_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static MethodHandle nauty_freedyn$handle() {
        return nauty_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static MemorySegment nauty_freedyn$address() {
        return nauty_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static void nauty_freedyn() {
        var mh$ = nauty_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nauty_check$descriptor() {
        return nauty_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static MethodHandle nauty_check$handle() {
        return nauty_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static MemorySegment nauty_check$address() {
        return nauty_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static void nauty_check(int x0, int x1, int x2, int x3) {
        var mh$ = nauty_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naugraph_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naugraph_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor naugraph_check$descriptor() {
        return naugraph_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static MethodHandle naugraph_check$handle() {
        return naugraph_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static MemorySegment naugraph_check$address() {
        return naugraph_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static void naugraph_check(int x0, int x1, int x2, int x3) {
        var mh$ = naugraph_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naugraph_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautil_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautil_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nautil_check$descriptor() {
        return nautil_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static MethodHandle nautil_check$handle() {
        return nautil_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static MemorySegment nautil_check$address() {
        return nautil_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static void nautil_check(int x0, int x1, int x2, int x3) {
        var mh$ = nautil_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautil_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautil_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautil_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static FunctionDescriptor nautil_freedyn$descriptor() {
        return nautil_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static MethodHandle nautil_freedyn$handle() {
        return nautil_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static MemorySegment nautil_freedyn$address() {
        return nautil_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static void nautil_freedyn() {
        var mh$ = nautil_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautil_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naugraph_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naugraph_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static FunctionDescriptor naugraph_freedyn$descriptor() {
        return naugraph_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static MethodHandle naugraph_freedyn$handle() {
        return naugraph_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static MemorySegment naugraph_freedyn$address() {
        return naugraph_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static void naugraph_freedyn() {
        var mh$ = naugraph_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naugraph_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class densenauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("densenauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static FunctionDescriptor densenauty$descriptor() {
        return densenauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static MethodHandle densenauty$handle() {
        return densenauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static MemorySegment densenauty$address() {
        return densenauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static void densenauty(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7, MemorySegment x8) {
        var mh$ = densenauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("densenauty", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writegroupsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_DOUBLE,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writegroupsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static FunctionDescriptor writegroupsize$descriptor() {
        return writegroupsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static MethodHandle writegroupsize$handle() {
        return writegroupsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static MemorySegment writegroupsize$address() {
        return writegroupsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static void writegroupsize(MemorySegment x0, double x1, int x2) {
        var mh$ = writegroupsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writegroupsize", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labelorg$constants {
        public static final OfInt LAYOUT = nautinv_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("labelorg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static OfInt labelorg$layout() {
        return labelorg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static MemorySegment labelorg$segment() {
        return labelorg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static int labelorg() {
        return labelorg$constants.SEGMENT.get(labelorg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static void labelorg(int varValue) {
        labelorg$constants.SEGMENT.set(labelorg$constants.LAYOUT, 0L, varValue);
    }

    private static class nauty_kill_request$constants {
        public static final OfInt LAYOUT = nautinv_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("nauty_kill_request").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static OfInt nauty_kill_request$layout() {
        return nauty_kill_request$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static MemorySegment nauty_kill_request$segment() {
        return nauty_kill_request$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static int nauty_kill_request() {
        return nauty_kill_request$constants.SEGMENT.get(nauty_kill_request$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static void nauty_kill_request(int varValue) {
        nauty_kill_request$constants.SEGMENT.set(nauty_kill_request$constants.LAYOUT, 0L, varValue);
    }

    private static class adjacencies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjacencies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor adjacencies$descriptor() {
        return adjacencies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle adjacencies$handle() {
        return adjacencies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment adjacencies$address() {
        return adjacencies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void adjacencies(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = adjacencies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjacencies", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static class adjtriang {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjtriang");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor adjtriang$descriptor() {
        return adjtriang.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle adjtriang$handle() {
        return adjtriang.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment adjtriang$address() {
        return adjtriang.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void adjtriang(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = adjtriang.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtriang", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellcliq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellcliq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellcliq$descriptor() {
        return cellcliq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellcliq$handle() {
        return cellcliq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellcliq$address() {
        return cellcliq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellcliq(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellcliq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellcliq", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellfano {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellfano");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellfano$descriptor() {
        return cellfano.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellfano$handle() {
        return cellfano.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellfano$address() {
        return cellfano.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellfano(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellfano.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellfano", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellfano2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellfano2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellfano2$descriptor() {
        return cellfano2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellfano2$handle() {
        return cellfano2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellfano2$address() {
        return cellfano2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellfano2(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellfano2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellfano2", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellind$descriptor() {
        return cellind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellind$handle() {
        return cellind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellind$address() {
        return cellind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellind(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellind", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellquads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellquads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellquads$descriptor() {
        return cellquads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellquads$handle() {
        return cellquads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellquads$address() {
        return cellquads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellquads(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellquads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellquads", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellquins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellquins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellquins$descriptor() {
        return cellquins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellquins$handle() {
        return cellquins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellquins$address() {
        return cellquins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellquins(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellquins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellquins", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class celltrips {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("celltrips");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor celltrips$descriptor() {
        return celltrips.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle celltrips$handle() {
        return celltrips.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment celltrips$address() {
        return celltrips.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void celltrips(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = celltrips.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("celltrips", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellstarts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellstarts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static FunctionDescriptor cellstarts$descriptor() {
        return cellstarts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static MethodHandle cellstarts$handle() {
        return cellstarts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static MemorySegment cellstarts$address() {
        return cellstarts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static void cellstarts(MemorySegment x0, int x1, MemorySegment x2, int x3, int x4) {
        var mh$ = cellstarts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellstarts", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cliques$descriptor() {
        return cliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cliques$handle() {
        return cliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cliques$address() {
        return cliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cliques(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cliques", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class distances {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("distances");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor distances$descriptor() {
        return distances.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle distances$handle() {
        return distances.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment distances$address() {
        return distances.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void distances(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = distances.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("distances", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbigcells {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getbigcells");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static FunctionDescriptor getbigcells$descriptor() {
        return getbigcells.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static MethodHandle getbigcells$handle() {
        return getbigcells.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static MemorySegment getbigcells$address() {
        return getbigcells.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static void getbigcells(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = getbigcells.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbigcells", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class indsets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("indsets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor indsets$descriptor() {
        return indsets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle indsets$handle() {
        return indsets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment indsets$address() {
        return indsets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void indsets(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = indsets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("indsets", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautinv_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautinv_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nautinv_check$descriptor() {
        return nautinv_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static MethodHandle nautinv_check$handle() {
        return nautinv_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static MemorySegment nautinv_check$address() {
        return nautinv_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static void nautinv_check(int x0, int x1, int x2, int x3) {
        var mh$ = nautinv_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautinv_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautinv_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautinv_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static FunctionDescriptor nautinv_freedyn$descriptor() {
        return nautinv_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static MethodHandle nautinv_freedyn$handle() {
        return nautinv_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static MemorySegment nautinv_freedyn$address() {
        return nautinv_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static void nautinv_freedyn() {
        var mh$ = nautinv_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautinv_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quadruples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quadruples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor quadruples$descriptor() {
        return quadruples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle quadruples$handle() {
        return quadruples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment quadruples$address() {
        return quadruples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void quadruples(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = quadruples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quadruples", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refinvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refinvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor refinvar$descriptor() {
        return refinvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle refinvar$handle() {
        return refinvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment refinvar$address() {
        return refinvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void refinvar(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = refinvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refinvar", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setnbhd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setnbhd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static FunctionDescriptor setnbhd$descriptor() {
        return setnbhd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static MethodHandle setnbhd$handle() {
        return setnbhd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static MemorySegment setnbhd$address() {
        return setnbhd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static void setnbhd(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = setnbhd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setnbhd", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class triples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("triples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor triples$descriptor() {
        return triples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle triples$handle() {
        return triples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment triples$address() {
        return triples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void triples(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = triples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("triples", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class twopaths {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_POINTER,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT,
            nautinv_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("twopaths");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor twopaths$descriptor() {
        return twopaths.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle twopaths$handle() {
        return twopaths.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment twopaths$address() {
        return twopaths.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void twopaths(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = twopaths.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("twopaths", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = nautinv_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final long _POSIX_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VERSION 200809
     * }
     */
    public static long _POSIX_VERSION() {
        return _POSIX_VERSION;
    }
    private static final long __POSIX2_THIS_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define __POSIX2_THIS_VERSION 200809
     * }
     */
    public static long __POSIX2_THIS_VERSION() {
        return __POSIX2_THIS_VERSION;
    }
    private static final long _POSIX2_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_VERSION 200809
     * }
     */
    public static long _POSIX2_VERSION() {
        return _POSIX2_VERSION;
    }
    private static final long _POSIX2_C_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_VERSION 200809
     * }
     */
    public static long _POSIX2_C_VERSION() {
        return _POSIX2_C_VERSION;
    }
    private static final long _POSIX2_C_BIND = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_BIND 200809
     * }
     */
    public static long _POSIX2_C_BIND() {
        return _POSIX2_C_BIND;
    }
    private static final long _POSIX2_C_DEV = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_DEV 200809
     * }
     */
    public static long _POSIX2_C_DEV() {
        return _POSIX2_C_DEV;
    }
    private static final long _POSIX2_SW_DEV = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_SW_DEV 200809
     * }
     */
    public static long _POSIX2_SW_DEV() {
        return _POSIX2_SW_DEV;
    }
    private static final long _POSIX2_LOCALEDEF = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LOCALEDEF 200809
     * }
     */
    public static long _POSIX2_LOCALEDEF() {
        return _POSIX2_LOCALEDEF;
    }
    private static final long _POSIX_PRIORITY_SCHEDULING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITY_SCHEDULING 200809
     * }
     */
    public static long _POSIX_PRIORITY_SCHEDULING() {
        return _POSIX_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_SYNCHRONIZED_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYNCHRONIZED_IO 200809
     * }
     */
    public static long _POSIX_SYNCHRONIZED_IO() {
        return _POSIX_SYNCHRONIZED_IO;
    }
    private static final long _POSIX_FSYNC = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_FSYNC 200809
     * }
     */
    public static long _POSIX_FSYNC() {
        return _POSIX_FSYNC;
    }
    private static final long _POSIX_MAPPED_FILES = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAPPED_FILES 200809
     * }
     */
    public static long _POSIX_MAPPED_FILES() {
        return _POSIX_MAPPED_FILES;
    }
    private static final long _POSIX_MEMLOCK = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK 200809
     * }
     */
    public static long _POSIX_MEMLOCK() {
        return _POSIX_MEMLOCK;
    }
    private static final long _POSIX_MEMLOCK_RANGE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK_RANGE 200809
     * }
     */
    public static long _POSIX_MEMLOCK_RANGE() {
        return _POSIX_MEMLOCK_RANGE;
    }
    private static final long _POSIX_MEMORY_PROTECTION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMORY_PROTECTION 200809
     * }
     */
    public static long _POSIX_MEMORY_PROTECTION() {
        return _POSIX_MEMORY_PROTECTION;
    }
    private static final int _POSIX_VDISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VDISABLE 0
     * }
     */
    public static int _POSIX_VDISABLE() {
        return _POSIX_VDISABLE;
    }
    private static final long _POSIX_THREADS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREADS 200809
     * }
     */
    public static long _POSIX_THREADS() {
        return _POSIX_THREADS;
    }
    private static final long _POSIX_THREAD_SAFE_FUNCTIONS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SAFE_FUNCTIONS 200809
     * }
     */
    public static long _POSIX_THREAD_SAFE_FUNCTIONS() {
        return _POSIX_THREAD_SAFE_FUNCTIONS;
    }
    private static final long _POSIX_THREAD_PRIORITY_SCHEDULING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIORITY_SCHEDULING 200809
     * }
     */
    public static long _POSIX_THREAD_PRIORITY_SCHEDULING() {
        return _POSIX_THREAD_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_THREAD_ATTR_STACKSIZE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKSIZE 200809
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKSIZE() {
        return _POSIX_THREAD_ATTR_STACKSIZE;
    }
    private static final long _POSIX_THREAD_ATTR_STACKADDR = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKADDR 200809
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKADDR() {
        return _POSIX_THREAD_ATTR_STACKADDR;
    }
    private static final long _POSIX_THREAD_PRIO_INHERIT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_INHERIT 200809
     * }
     */
    public static long _POSIX_THREAD_PRIO_INHERIT() {
        return _POSIX_THREAD_PRIO_INHERIT;
    }
    private static final long _POSIX_THREAD_PRIO_PROTECT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_PROTECT 200809
     * }
     */
    public static long _POSIX_THREAD_PRIO_PROTECT() {
        return _POSIX_THREAD_PRIO_PROTECT;
    }
    private static final long _POSIX_THREAD_ROBUST_PRIO_INHERIT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ROBUST_PRIO_INHERIT 200809
     * }
     */
    public static long _POSIX_THREAD_ROBUST_PRIO_INHERIT() {
        return _POSIX_THREAD_ROBUST_PRIO_INHERIT;
    }
    private static final int _POSIX_THREAD_ROBUST_PRIO_PROTECT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ROBUST_PRIO_PROTECT -1
     * }
     */
    public static int _POSIX_THREAD_ROBUST_PRIO_PROTECT() {
        return _POSIX_THREAD_ROBUST_PRIO_PROTECT;
    }
    private static final long _POSIX_SEMAPHORES = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEMAPHORES 200809
     * }
     */
    public static long _POSIX_SEMAPHORES() {
        return _POSIX_SEMAPHORES;
    }
    private static final long _POSIX_REALTIME_SIGNALS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REALTIME_SIGNALS 200809
     * }
     */
    public static long _POSIX_REALTIME_SIGNALS() {
        return _POSIX_REALTIME_SIGNALS;
    }
    private static final long _POSIX_ASYNCHRONOUS_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ASYNCHRONOUS_IO 200809
     * }
     */
    public static long _POSIX_ASYNCHRONOUS_IO() {
        return _POSIX_ASYNCHRONOUS_IO;
    }
    private static final long _POSIX_PRIORITIZED_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITIZED_IO 200809
     * }
     */
    public static long _POSIX_PRIORITIZED_IO() {
        return _POSIX_PRIORITIZED_IO;
    }
    private static final long _POSIX_SHARED_MEMORY_OBJECTS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHARED_MEMORY_OBJECTS 200809
     * }
     */
    public static long _POSIX_SHARED_MEMORY_OBJECTS() {
        return _POSIX_SHARED_MEMORY_OBJECTS;
    }
    private static final long _POSIX_READER_WRITER_LOCKS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_READER_WRITER_LOCKS 200809
     * }
     */
    public static long _POSIX_READER_WRITER_LOCKS() {
        return _POSIX_READER_WRITER_LOCKS;
    }
    private static final long _POSIX_TIMEOUTS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMEOUTS 200809
     * }
     */
    public static long _POSIX_TIMEOUTS() {
        return _POSIX_TIMEOUTS;
    }
    private static final long _POSIX_SPIN_LOCKS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPIN_LOCKS 200809
     * }
     */
    public static long _POSIX_SPIN_LOCKS() {
        return _POSIX_SPIN_LOCKS;
    }
    private static final long _POSIX_SPAWN = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPAWN 200809
     * }
     */
    public static long _POSIX_SPAWN() {
        return _POSIX_SPAWN;
    }
    private static final long _POSIX_TIMERS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMERS 200809
     * }
     */
    public static long _POSIX_TIMERS() {
        return _POSIX_TIMERS;
    }
    private static final long _POSIX_BARRIERS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_BARRIERS 200809
     * }
     */
    public static long _POSIX_BARRIERS() {
        return _POSIX_BARRIERS;
    }
    private static final long _POSIX_MESSAGE_PASSING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MESSAGE_PASSING 200809
     * }
     */
    public static long _POSIX_MESSAGE_PASSING() {
        return _POSIX_MESSAGE_PASSING;
    }
    private static final long _POSIX_THREAD_PROCESS_SHARED = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PROCESS_SHARED 200809
     * }
     */
    public static long _POSIX_THREAD_PROCESS_SHARED() {
        return _POSIX_THREAD_PROCESS_SHARED;
    }
    private static final long _POSIX_CLOCK_SELECTION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCK_SELECTION 200809
     * }
     */
    public static long _POSIX_CLOCK_SELECTION() {
        return _POSIX_CLOCK_SELECTION;
    }
    private static final long _POSIX_ADVISORY_INFO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ADVISORY_INFO 200809
     * }
     */
    public static long _POSIX_ADVISORY_INFO() {
        return _POSIX_ADVISORY_INFO;
    }
    private static final long _POSIX_IPV6 = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_IPV6 200809
     * }
     */
    public static long _POSIX_IPV6() {
        return _POSIX_IPV6;
    }
    private static final long _POSIX_RAW_SOCKETS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RAW_SOCKETS 200809
     * }
     */
    public static long _POSIX_RAW_SOCKETS() {
        return _POSIX_RAW_SOCKETS;
    }
    private static final long _POSIX2_CHAR_TERM = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHAR_TERM 200809
     * }
     */
    public static long _POSIX2_CHAR_TERM() {
        return _POSIX2_CHAR_TERM;
    }
    private static final int _POSIX_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_SPORADIC_SERVER() {
        return _POSIX_SPORADIC_SERVER;
    }
    private static final int _POSIX_THREAD_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_THREAD_SPORADIC_SERVER() {
        return _POSIX_THREAD_SPORADIC_SERVER;
    }
    private static final int _POSIX_TRACE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE -1
     * }
     */
    public static int _POSIX_TRACE() {
        return _POSIX_TRACE;
    }
    private static final int _POSIX_TRACE_EVENT_FILTER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_EVENT_FILTER -1
     * }
     */
    public static int _POSIX_TRACE_EVENT_FILTER() {
        return _POSIX_TRACE_EVENT_FILTER;
    }
    private static final int _POSIX_TRACE_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_INHERIT -1
     * }
     */
    public static int _POSIX_TRACE_INHERIT() {
        return _POSIX_TRACE_INHERIT;
    }
    private static final int _POSIX_TRACE_LOG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_LOG -1
     * }
     */
    public static int _POSIX_TRACE_LOG() {
        return _POSIX_TRACE_LOG;
    }
    private static final int _POSIX_TYPED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TYPED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_TYPED_MEMORY_OBJECTS() {
        return _POSIX_TYPED_MEMORY_OBJECTS;
    }
    private static final int _POSIX_V7_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LPBIG_OFFBIG -1
     * }
     */
    public static int _POSIX_V7_LPBIG_OFFBIG() {
        return _POSIX_V7_LPBIG_OFFBIG;
    }
    private static final int _POSIX_V6_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LPBIG_OFFBIG -1
     * }
     */
    public static int _POSIX_V6_LPBIG_OFFBIG() {
        return _POSIX_V6_LPBIG_OFFBIG;
    }
    private static final int _XBS5_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LPBIG_OFFBIG -1
     * }
     */
    public static int _XBS5_LPBIG_OFFBIG() {
        return _XBS5_LPBIG_OFFBIG;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32_CFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFF32_CFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFF32_CFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFF32_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32_LDFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFF32_LDFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFF32_LDFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFF32_LDFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG_CFLAGS "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
     * }
     */
    public static MemorySegment __ILP32_OFFBIG_CFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFFBIG_CFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64");
        }
        return Holder.__ILP32_OFFBIG_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG_LDFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFFBIG_LDFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFFBIG_LDFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFFBIG_LDFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64_CFLAGS "-m64"
     * }
     */
    public static MemorySegment __LP64_OFF64_CFLAGS() {
        class Holder {
            static final MemorySegment __LP64_OFF64_CFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m64");
        }
        return Holder.__LP64_OFF64_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64_LDFLAGS "-m64"
     * }
     */
    public static MemorySegment __LP64_OFF64_LDFLAGS() {
        class Holder {
            static final MemorySegment __LP64_OFF64_LDFLAGS
                = nautinv_h.LIBRARY_ARENA.allocateFrom("-m64");
        }
        return Holder.__LP64_OFF64_LDFLAGS;
    }
    private static final int L_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define L_SET 0
     * }
     */
    public static int L_SET() {
        return L_SET;
    }
    private static final int L_INCR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define L_INCR 1
     * }
     */
    public static int L_INCR() {
        return L_INCR;
    }
    private static final int L_XTND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define L_XTND 2
     * }
     */
    public static int L_XTND() {
        return L_XTND;
    }
    private static final int _SC_PAGE_SIZE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGE_SIZE 30
     * }
     */
    public static int _SC_PAGE_SIZE() {
        return _SC_PAGE_SIZE;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 1
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS 4
     * }
     */
    public static int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS 5
     * }
     */
    public static int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS;
    }
    private static final int __WCLONE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCLONE 2147483648
     * }
     */
    public static int __WCLONE() {
        return __WCLONE;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int PTHREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int PTHREAD_DESTRUCTOR_ITERATIONS() {
        return PTHREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int SEM_VALUE_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SEM_VALUE_MAX 2147483647
     * }
     */
    public static int SEM_VALUE_MAX() {
        return SEM_VALUE_MAX;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final int BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_BASE_MAX 99
     * }
     */
    public static int BC_BASE_MAX() {
        return BC_BASE_MAX;
    }
    private static final int BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define BC_DIM_MAX 2048
     * }
     */
    public static int BC_DIM_MAX() {
        return BC_DIM_MAX;
    }
    private static final int BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_SCALE_MAX 99
     * }
     */
    public static int BC_SCALE_MAX() {
        return BC_SCALE_MAX;
    }
    private static final int BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define BC_STRING_MAX 1000
     * }
     */
    public static int BC_STRING_MAX() {
        return BC_STRING_MAX;
    }
    private static final int EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXPR_NEST_MAX 32
     * }
     */
    public static int EXPR_NEST_MAX() {
        return EXPR_NEST_MAX;
    }
    private static final int LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LINE_MAX 2048
     * }
     */
    public static int LINE_MAX() {
        return LINE_MAX;
    }
    private static final int RE_DUP_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RE_DUP_MAX 32767
     * }
     */
    public static int RE_DUP_MAX() {
        return RE_DUP_MAX;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define COUNTER_FMT "%llu"
     * }
     */
    public static MemorySegment COUNTER_FMT() {
        class Holder {
            static final MemorySegment COUNTER_FMT
                = nautinv_h.LIBRARY_ARENA.allocateFrom("%llu");
        }
        return Holder.COUNTER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define COUNTER_FMT_RAW "llu"
     * }
     */
    public static MemorySegment COUNTER_FMT_RAW() {
        class Holder {
            static final MemorySegment COUNTER_FMT_RAW
                = nautinv_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.COUNTER_FMT_RAW;
    }
    private static final int NAUTYVERSIONID = (int)29300L;
    /**
     * {@snippet lang=c :
     * #define NAUTYVERSIONID 29300
     * }
     */
    public static int NAUTYVERSIONID() {
        return NAUTYVERSIONID;
    }
    private static final int NAUTYREQUIRED = (int)29300L;
    /**
     * {@snippet lang=c :
     * #define NAUTYREQUIRED 29300
     * }
     */
    public static int NAUTYREQUIRED() {
        return NAUTYREQUIRED;
    }
    /**
     * {@snippet lang=c :
     * #define NAUTYVERSION "2.9.3 (64 bits)"
     * }
     */
    public static MemorySegment NAUTYVERSION() {
        class Holder {
            static final MemorySegment NAUTYVERSION
                = nautinv_h.LIBRARY_ARENA.allocateFrom("2.9.3 (64 bits)");
        }
        return Holder.NAUTYVERSION;
    }
    private static final long MSK3232 = -4294967296L;
    /**
     * {@snippet lang=c :
     * #define MSK3232 -4294967296
     * }
     */
    public static long MSK3232() {
        return MSK3232;
    }
    private static final long MSK1648 = -281474976710656L;
    /**
     * {@snippet lang=c :
     * #define MSK1648 -281474976710656
     * }
     */
    public static long MSK1648() {
        return MSK1648;
    }
    private static final long MSK0856 = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MSK0856 -72057594037927936
     * }
     */
    public static long MSK0856() {
        return MSK0856;
    }
    private static final long MSK1632 = 281470681743360L;
    /**
     * {@snippet lang=c :
     * #define MSK1632 281470681743360
     * }
     */
    public static long MSK1632() {
        return MSK1632;
    }
    private static final long MSK0840 = 280375465082880L;
    /**
     * {@snippet lang=c :
     * #define MSK0840 280375465082880
     * }
     */
    public static long MSK0840() {
        return MSK0840;
    }
    private static final long MSK1616 = 4294901760L;
    /**
     * {@snippet lang=c :
     * #define MSK1616 4294901760
     * }
     */
    public static long MSK1616() {
        return MSK1616;
    }
    private static final long MSK0824 = 4278190080L;
    /**
     * {@snippet lang=c :
     * #define MSK0824 4278190080
     * }
     */
    public static long MSK0824() {
        return MSK0824;
    }
    private static final long MSK0808 = 65280L;
    /**
     * {@snippet lang=c :
     * #define MSK0808 65280
     * }
     */
    public static long MSK0808() {
        return MSK0808;
    }
    private static final long MSK63C = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MSK63C 9223372036854775807
     * }
     */
    public static long MSK63C() {
        return MSK63C;
    }
    private static final long MSK31C = 2147483647L;
    /**
     * {@snippet lang=c :
     * #define MSK31C 2147483647
     * }
     */
    public static long MSK31C() {
        return MSK31C;
    }
    private static final long MSK15C = 32767L;
    /**
     * {@snippet lang=c :
     * #define MSK15C 32767
     * }
     */
    public static long MSK15C() {
        return MSK15C;
    }
    private static final long MSK64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MSK64 -1
     * }
     */
    public static long MSK64() {
        return MSK64;
    }
    private static final long MSK32 = 4294967295L;
    /**
     * {@snippet lang=c :
     * #define MSK32 4294967295
     * }
     */
    public static long MSK32() {
        return MSK32;
    }
    private static final long MSK16 = 65535L;
    /**
     * {@snippet lang=c :
     * #define MSK16 65535
     * }
     */
    public static long MSK16() {
        return MSK16;
    }
    private static final long MSK8 = 255L;
    /**
     * {@snippet lang=c :
     * #define MSK8 255
     * }
     */
    public static long MSK8() {
        return MSK8;
    }
    /**
     * {@snippet lang=c :
     * #define SETWORD_DEC_FORMAT "%lu"
     * }
     */
    public static MemorySegment SETWORD_DEC_FORMAT() {
        class Holder {
            static final MemorySegment SETWORD_DEC_FORMAT
                = nautinv_h.LIBRARY_ARENA.allocateFrom("%lu");
        }
        return Holder.SETWORD_DEC_FORMAT;
    }
    /**
     * {@snippet lang=c :
     * #define SETWORD_FORMAT "%016lx"
     * }
     */
    public static MemorySegment SETWORD_FORMAT() {
        class Holder {
            static final MemorySegment SETWORD_FORMAT
                = nautinv_h.LIBRARY_ARENA.allocateFrom("%016lx");
        }
        return Holder.SETWORD_FORMAT;
    }
    private static final long ALLBITS = -1L;
    /**
     * {@snippet lang=c :
     * #define ALLBITS -1
     * }
     */
    public static long ALLBITS() {
        return ALLBITS;
    }
    private static final MemorySegment NILFUNCTION = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILFUNCTION (void*) 0
     * }
     */
    public static MemorySegment NILFUNCTION() {
        return NILFUNCTION;
    }
    private static final MemorySegment NILSET = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILSET (void*) 0
     * }
     */
    public static MemorySegment NILSET() {
        return NILSET;
    }
    private static final MemorySegment NILGRAPH = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILGRAPH (void*) 0
     * }
     */
    public static MemorySegment NILGRAPH() {
        return NILGRAPH;
    }
}

