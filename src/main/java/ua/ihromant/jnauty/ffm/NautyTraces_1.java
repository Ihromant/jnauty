// Generated by jextract

package ua.ihromant.jnauty.ffm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class NautyTraces_1 extends NautyTraces_2 {

    NautyTraces_1() {
        // Should not be called directly
    }
    private static final int _SC_DEVICE_IO = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_IO = 140
     * }
     */
    public static int _SC_DEVICE_IO() {
        return _SC_DEVICE_IO;
    }
    private static final int _SC_DEVICE_SPECIFIC = (int)141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_SPECIFIC = 141
     * }
     */
    public static int _SC_DEVICE_SPECIFIC() {
        return _SC_DEVICE_SPECIFIC;
    }
    private static final int _SC_DEVICE_SPECIFIC_R = (int)142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_SPECIFIC_R = 142
     * }
     */
    public static int _SC_DEVICE_SPECIFIC_R() {
        return _SC_DEVICE_SPECIFIC_R;
    }
    private static final int _SC_FD_MGMT = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FD_MGMT = 143
     * }
     */
    public static int _SC_FD_MGMT() {
        return _SC_FD_MGMT;
    }
    private static final int _SC_FIFO = (int)144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FIFO = 144
     * }
     */
    public static int _SC_FIFO() {
        return _SC_FIFO;
    }
    private static final int _SC_PIPE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PIPE = 145
     * }
     */
    public static int _SC_PIPE() {
        return _SC_PIPE;
    }
    private static final int _SC_FILE_ATTRIBUTES = (int)146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_ATTRIBUTES = 146
     * }
     */
    public static int _SC_FILE_ATTRIBUTES() {
        return _SC_FILE_ATTRIBUTES;
    }
    private static final int _SC_FILE_LOCKING = (int)147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_LOCKING = 147
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_FILE_SYSTEM = (int)148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_SYSTEM = 148
     * }
     */
    public static int _SC_FILE_SYSTEM() {
        return _SC_FILE_SYSTEM;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MONOTONIC_CLOCK = 149
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MULTI_PROCESS = (int)150L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MULTI_PROCESS = 150
     * }
     */
    public static int _SC_MULTI_PROCESS() {
        return _SC_MULTI_PROCESS;
    }
    private static final int _SC_SINGLE_PROCESS = (int)151L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SINGLE_PROCESS = 151
     * }
     */
    public static int _SC_SINGLE_PROCESS() {
        return _SC_SINGLE_PROCESS;
    }
    private static final int _SC_NETWORKING = (int)152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NETWORKING = 152
     * }
     */
    public static int _SC_NETWORKING() {
        return _SC_NETWORKING;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)153L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_READER_WRITER_LOCKS = 153
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_SPIN_LOCKS = (int)154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPIN_LOCKS = 154
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_REGEXP = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_REGEXP = 155
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_REGEX_VERSION = (int)156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_REGEX_VERSION = 156
     * }
     */
    public static int _SC_REGEX_VERSION() {
        return _SC_REGEX_VERSION;
    }
    private static final int _SC_SHELL = (int)157L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SHELL = 157
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SIGNALS = (int)158L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SIGNALS = 158
     * }
     */
    public static int _SC_SIGNALS() {
        return _SC_SIGNALS;
    }
    private static final int _SC_SPAWN = (int)159L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPAWN = 159
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPORADIC_SERVER = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPORADIC_SERVER = 160
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_SPORADIC_SERVER = 161
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_SYSTEM_DATABASE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYSTEM_DATABASE = 162
     * }
     */
    public static int _SC_SYSTEM_DATABASE() {
        return _SC_SYSTEM_DATABASE;
    }
    private static final int _SC_SYSTEM_DATABASE_R = (int)163L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYSTEM_DATABASE_R = 163
     * }
     */
    public static int _SC_SYSTEM_DATABASE_R() {
        return _SC_SYSTEM_DATABASE_R;
    }
    private static final int _SC_TIMEOUTS = (int)164L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TIMEOUTS = 164
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)165L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TYPED_MEMORY_OBJECTS = 165
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_USER_GROUPS = (int)166L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_USER_GROUPS = 166
     * }
     */
    public static int _SC_USER_GROUPS() {
        return _SC_USER_GROUPS;
    }
    private static final int _SC_USER_GROUPS_R = (int)167L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_USER_GROUPS_R = 167
     * }
     */
    public static int _SC_USER_GROUPS_R() {
        return _SC_USER_GROUPS_R;
    }
    private static final int _SC_2_PBS = (int)168L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS = 168
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)169L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_ACCOUNTING = 169
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_LOCATE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_LOCATE = 170
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)171L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_MESSAGE = 171
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)172L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_TRACK = 172
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_SYMLOOP_MAX = (int)173L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYMLOOP_MAX = 173
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_STREAMS = (int)174L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_STREAMS = 174
     * }
     */
    public static int _SC_STREAMS() {
        return _SC_STREAMS;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)175L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_CHECKPOINT = 175
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)176L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_ILP32_OFF32 = 176
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)177L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_ILP32_OFFBIG = 177
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)178L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_LP64_OFF64 = 178
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)179L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_LPBIG_OFFBIG = 179
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_HOST_NAME_MAX = (int)180L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_HOST_NAME_MAX = 180
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_TRACE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE = 181
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)182L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_EVENT_FILTER = 182
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)183L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_INHERIT = 183
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)184L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_LOG = 184
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_LEVEL1_ICACHE_SIZE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_SIZE = 185
     * }
     */
    public static int _SC_LEVEL1_ICACHE_SIZE() {
        return _SC_LEVEL1_ICACHE_SIZE;
    }
    private static final int _SC_LEVEL1_ICACHE_ASSOC = (int)186L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_ASSOC = 186
     * }
     */
    public static int _SC_LEVEL1_ICACHE_ASSOC() {
        return _SC_LEVEL1_ICACHE_ASSOC;
    }
    private static final int _SC_LEVEL1_ICACHE_LINESIZE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_LINESIZE = 187
     * }
     */
    public static int _SC_LEVEL1_ICACHE_LINESIZE() {
        return _SC_LEVEL1_ICACHE_LINESIZE;
    }
    private static final int _SC_LEVEL1_DCACHE_SIZE = (int)188L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_SIZE = 188
     * }
     */
    public static int _SC_LEVEL1_DCACHE_SIZE() {
        return _SC_LEVEL1_DCACHE_SIZE;
    }
    private static final int _SC_LEVEL1_DCACHE_ASSOC = (int)189L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_ASSOC = 189
     * }
     */
    public static int _SC_LEVEL1_DCACHE_ASSOC() {
        return _SC_LEVEL1_DCACHE_ASSOC;
    }
    private static final int _SC_LEVEL1_DCACHE_LINESIZE = (int)190L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_LINESIZE = 190
     * }
     */
    public static int _SC_LEVEL1_DCACHE_LINESIZE() {
        return _SC_LEVEL1_DCACHE_LINESIZE;
    }
    private static final int _SC_LEVEL2_CACHE_SIZE = (int)191L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_SIZE = 191
     * }
     */
    public static int _SC_LEVEL2_CACHE_SIZE() {
        return _SC_LEVEL2_CACHE_SIZE;
    }
    private static final int _SC_LEVEL2_CACHE_ASSOC = (int)192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_ASSOC = 192
     * }
     */
    public static int _SC_LEVEL2_CACHE_ASSOC() {
        return _SC_LEVEL2_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL2_CACHE_LINESIZE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_LINESIZE = 193
     * }
     */
    public static int _SC_LEVEL2_CACHE_LINESIZE() {
        return _SC_LEVEL2_CACHE_LINESIZE;
    }
    private static final int _SC_LEVEL3_CACHE_SIZE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_SIZE = 194
     * }
     */
    public static int _SC_LEVEL3_CACHE_SIZE() {
        return _SC_LEVEL3_CACHE_SIZE;
    }
    private static final int _SC_LEVEL3_CACHE_ASSOC = (int)195L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_ASSOC = 195
     * }
     */
    public static int _SC_LEVEL3_CACHE_ASSOC() {
        return _SC_LEVEL3_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL3_CACHE_LINESIZE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_LINESIZE = 196
     * }
     */
    public static int _SC_LEVEL3_CACHE_LINESIZE() {
        return _SC_LEVEL3_CACHE_LINESIZE;
    }
    private static final int _SC_LEVEL4_CACHE_SIZE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_SIZE = 197
     * }
     */
    public static int _SC_LEVEL4_CACHE_SIZE() {
        return _SC_LEVEL4_CACHE_SIZE;
    }
    private static final int _SC_LEVEL4_CACHE_ASSOC = (int)198L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_ASSOC = 198
     * }
     */
    public static int _SC_LEVEL4_CACHE_ASSOC() {
        return _SC_LEVEL4_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL4_CACHE_LINESIZE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_LINESIZE = 199
     * }
     */
    public static int _SC_LEVEL4_CACHE_LINESIZE() {
        return _SC_LEVEL4_CACHE_LINESIZE;
    }
    private static final int _SC_IPV6 = (int)235L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_IPV6 = 235
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)236L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_RAW_SOCKETS = 236
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_V7_ILP32_OFF32 = (int)237L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_ILP32_OFF32 = 237
     * }
     */
    public static int _SC_V7_ILP32_OFF32() {
        return _SC_V7_ILP32_OFF32;
    }
    private static final int _SC_V7_ILP32_OFFBIG = (int)238L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_ILP32_OFFBIG = 238
     * }
     */
    public static int _SC_V7_ILP32_OFFBIG() {
        return _SC_V7_ILP32_OFFBIG;
    }
    private static final int _SC_V7_LP64_OFF64 = (int)239L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_LP64_OFF64 = 239
     * }
     */
    public static int _SC_V7_LP64_OFF64() {
        return _SC_V7_LP64_OFF64;
    }
    private static final int _SC_V7_LPBIG_OFFBIG = (int)240L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_LPBIG_OFFBIG = 240
     * }
     */
    public static int _SC_V7_LPBIG_OFFBIG() {
        return _SC_V7_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)241L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SS_REPL_MAX = 241
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)242L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_EVENT_NAME_MAX = 242
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)243L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_NAME_MAX = 243
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)244L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_SYS_MAX = 244
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)245L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_USER_EVENT_MAX = 245
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_XOPEN_STREAMS = (int)246L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_STREAMS = 246
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_THREAD_ROBUST_PRIO_INHERIT = (int)247L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ROBUST_PRIO_INHERIT = 247
     * }
     */
    public static int _SC_THREAD_ROBUST_PRIO_INHERIT() {
        return _SC_THREAD_ROBUST_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_ROBUST_PRIO_PROTECT = (int)248L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ROBUST_PRIO_PROTECT = 248
     * }
     */
    public static int _SC_THREAD_ROBUST_PRIO_PROTECT() {
        return _SC_THREAD_ROBUST_PRIO_PROTECT;
    }
    private static final int _SC_MINSIGSTKSZ = (int)249L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MINSIGSTKSZ = 249
     * }
     */
    public static int _SC_MINSIGSTKSZ() {
        return _SC_MINSIGSTKSZ;
    }
    private static final int _SC_SIGSTKSZ = (int)250L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SIGSTKSZ = 250
     * }
     */
    public static int _SC_SIGSTKSZ() {
        return _SC_SIGSTKSZ;
    }
    private static final int _CS_PATH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_PATH = 0
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int _CS_V6_WIDTH_RESTRICTED_ENVS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V6_WIDTH_RESTRICTED_ENVS = 1
     * }
     */
    public static int _CS_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_GNU_LIBC_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_GNU_LIBC_VERSION = 2
     * }
     */
    public static int _CS_GNU_LIBC_VERSION() {
        return _CS_GNU_LIBC_VERSION;
    }
    private static final int _CS_GNU_LIBPTHREAD_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_GNU_LIBPTHREAD_VERSION = 3
     * }
     */
    public static int _CS_GNU_LIBPTHREAD_VERSION() {
        return _CS_GNU_LIBPTHREAD_VERSION;
    }
    private static final int _CS_V5_WIDTH_RESTRICTED_ENVS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V5_WIDTH_RESTRICTED_ENVS = 4
     * }
     */
    public static int _CS_V5_WIDTH_RESTRICTED_ENVS() {
        return _CS_V5_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_V7_WIDTH_RESTRICTED_ENVS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V7_WIDTH_RESTRICTED_ENVS = 5
     * }
     */
    public static int _CS_V7_WIDTH_RESTRICTED_ENVS() {
        return _CS_V7_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_LFS_CFLAGS = (int)1000L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_CFLAGS = 1000
     * }
     */
    public static int _CS_LFS_CFLAGS() {
        return _CS_LFS_CFLAGS;
    }
    private static final int _CS_LFS_LDFLAGS = (int)1001L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LDFLAGS = 1001
     * }
     */
    public static int _CS_LFS_LDFLAGS() {
        return _CS_LFS_LDFLAGS;
    }
    private static final int _CS_LFS_LIBS = (int)1002L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LIBS = 1002
     * }
     */
    public static int _CS_LFS_LIBS() {
        return _CS_LFS_LIBS;
    }
    private static final int _CS_LFS_LINTFLAGS = (int)1003L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LINTFLAGS = 1003
     * }
     */
    public static int _CS_LFS_LINTFLAGS() {
        return _CS_LFS_LINTFLAGS;
    }
    private static final int _CS_LFS64_CFLAGS = (int)1004L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_CFLAGS = 1004
     * }
     */
    public static int _CS_LFS64_CFLAGS() {
        return _CS_LFS64_CFLAGS;
    }
    private static final int _CS_LFS64_LDFLAGS = (int)1005L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LDFLAGS = 1005
     * }
     */
    public static int _CS_LFS64_LDFLAGS() {
        return _CS_LFS64_LDFLAGS;
    }
    private static final int _CS_LFS64_LIBS = (int)1006L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LIBS = 1006
     * }
     */
    public static int _CS_LFS64_LIBS() {
        return _CS_LFS64_LIBS;
    }
    private static final int _CS_LFS64_LINTFLAGS = (int)1007L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LINTFLAGS = 1007
     * }
     */
    public static int _CS_LFS64_LINTFLAGS() {
        return _CS_LFS64_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)1100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_CFLAGS = 1100
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)1101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LDFLAGS = 1101
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)1102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LIBS = 1102
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)1103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)1104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)1105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)1106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LIBS = 1106
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)1107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)1108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_CFLAGS = 1108
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)1109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LDFLAGS = 1109
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)1110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LIBS = 1110
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)1111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LINTFLAGS = 1111
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)1112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)1113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)1114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LIBS = 1114
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)1115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)1116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)1117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)1118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LIBS = 1118
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = (int)1119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)1120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)1121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)1122L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = (int)1123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)1124L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)1125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)1126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LIBS = 1126
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = (int)1127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)1128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)1129L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)1130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = (int)1131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_CFLAGS = (int)1132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = (int)1133L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LIBS = (int)1134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LIBS = 1134
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V7_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = (int)1135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = (int)1136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = (int)1137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LIBS = (int)1138L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = (int)1139L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_CFLAGS = (int)1140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LDFLAGS = (int)1141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LIBS = (int)1142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LIBS = 1142
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LIBS() {
        return _CS_POSIX_V7_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = (int)1143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = (int)1144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = (int)1145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = (int)1146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = (int)1147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_V6_ENV = (int)1148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V6_ENV = 1148
     * }
     */
    public static int _CS_V6_ENV() {
        return _CS_V6_ENV;
    }
    private static final int _CS_V7_ENV = (int)1149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V7_ENV = 1149
     * }
     */
    public static int _CS_V7_ENV() {
        return _CS_V7_ENV;
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static long pathconf(MemorySegment __path, int __name) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", __path, __name);
            }
            return (long)mh$.invokeExact(__path, __name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static long fpathconf(int __fd, int __name) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", __fd, __name);
            }
            return (long)mh$.invokeExact(__fd, __name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static long sysconf(int __name) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", __name);
            }
            return (long)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static long confstr(int __name, MemorySegment __buf, long __len) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", __name, __buf, __len);
            }
            return (long)mh$.invokeExact(__name, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor __getpgid$descriptor() {
        return __getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static MethodHandle __getpgid$handle() {
        return __getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static MemorySegment __getpgid$address() {
        return __getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static int __getpgid(int __pid) {
        var mh$ = __getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getpgid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static int getpgid(int __pid) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static int setpgid(int __pid, int __pgid) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", __pid, __pgid);
            }
            return (int)mh$.invokeExact(__pid, __pgid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static int getsid(int __pid) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static int getgroups(int __size, MemorySegment __list) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", __size, __list);
            }
            return (int)mh$.invokeExact(__size, __list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static int setuid(int __uid) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", __uid);
            }
            return (int)mh$.invokeExact(__uid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static int setreuid(int __ruid, int __euid) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", __ruid, __euid);
            }
            return (int)mh$.invokeExact(__ruid, __euid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static int seteuid(int __uid) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", __uid);
            }
            return (int)mh$.invokeExact(__uid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static int setgid(int __gid) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", __gid);
            }
            return (int)mh$.invokeExact(__gid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static int setregid(int __rgid, int __egid) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", __rgid, __egid);
            }
            return (int)mh$.invokeExact(__rgid, __egid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static int setegid(int __gid) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", __gid);
            }
            return (int)mh$.invokeExact(__gid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MemorySegment ttyname(int __fd) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", __fd);
            }
            return (MemorySegment)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static int ttyname_r(int __fd, MemorySegment __buf, long __buflen) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", __fd, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__fd, __buf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static int isatty(int __fd) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static int link(MemorySegment __from, MemorySegment __to) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", __from, __to);
            }
            return (int)mh$.invokeExact(__from, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static int linkat(int __fromfd, MemorySegment __from, int __tofd, MemorySegment __to, int __flags) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", __fromfd, __from, __tofd, __to, __flags);
            }
            return (int)mh$.invokeExact(__fromfd, __from, __tofd, __to, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static int symlink(MemorySegment __from, MemorySegment __to) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", __from, __to);
            }
            return (int)mh$.invokeExact(__from, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static long readlink(MemorySegment __path, MemorySegment __buf, long __len) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", __path, __buf, __len);
            }
            return (long)mh$.invokeExact(__path, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static int symlinkat(MemorySegment __from, int __tofd, MemorySegment __to) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", __from, __tofd, __to);
            }
            return (int)mh$.invokeExact(__from, __tofd, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static long readlinkat(int __fd, MemorySegment __path, MemorySegment __buf, long __len) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", __fd, __path, __buf, __len);
            }
            return (long)mh$.invokeExact(__fd, __path, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static int unlink(MemorySegment __name) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static int unlinkat(int __fd, MemorySegment __name, int __flag) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", __fd, __name, __flag);
            }
            return (int)mh$.invokeExact(__fd, __name, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static int rmdir(MemorySegment __path) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", __path);
            }
            return (int)mh$.invokeExact(__path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static int tcgetpgrp(int __fd) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static int tcsetpgrp(int __fd, int __pgrp_id) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", __fd, __pgrp_id);
            }
            return (int)mh$.invokeExact(__fd, __pgrp_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static int getlogin_r(MemorySegment __name, long __name_len) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", __name, __name_len);
            }
            return (int)mh$.invokeExact(__name, __name_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static int setlogin(MemorySegment __name) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = NautyTraces.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static int getopt(int ___argc, MemorySegment ___argv, MemorySegment __shortopts) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", ___argc, ___argv, __shortopts);
            }
            return (int)mh$.invokeExact(___argc, ___argv, __shortopts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static int gethostname(MemorySegment __name, long __len) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static int sethostname(MemorySegment __name, long __len) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static int sethostid(long __id) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", __id);
            }
            return (int)mh$.invokeExact(__id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static int getdomainname(MemorySegment __name, long __len) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static int setdomainname(MemorySegment __name, long __len) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vhangup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vhangup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static FunctionDescriptor vhangup$descriptor() {
        return vhangup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static MethodHandle vhangup$handle() {
        return vhangup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static MemorySegment vhangup$address() {
        return vhangup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static int vhangup() {
        var mh$ = vhangup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vhangup");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static int revoke(MemorySegment __file) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", __file);
            }
            return (int)mh$.invokeExact(__file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static int profil(MemorySegment __sample_buffer, long __size, long __offset, int __scale) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", __sample_buffer, __size, __offset, __scale);
            }
            return (int)mh$.invokeExact(__sample_buffer, __size, __offset, __scale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static int acct(MemorySegment __name) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static int daemon(int __nochdir, int __noclose) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", __nochdir, __noclose);
            }
            return (int)mh$.invokeExact(__nochdir, __noclose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static int chroot(MemorySegment __path) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", __path);
            }
            return (int)mh$.invokeExact(__path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MemorySegment getpass(MemorySegment __prompt) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", __prompt);
            }
            return (MemorySegment)mh$.invokeExact(__prompt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static int fsync(int __fd) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static int truncate(MemorySegment __file, long __length) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", __file, __length);
            }
            return (int)mh$.invokeExact(__file, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static int ftruncate(int __fd, long __length) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", __fd, __length);
            }
            return (int)mh$.invokeExact(__fd, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static int brk(MemorySegment __addr) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", __addr);
            }
            return (int)mh$.invokeExact(__addr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MemorySegment sbrk(long __delta) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", __delta);
            }
            return (MemorySegment)mh$.invokeExact(__delta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern long syscall(long __sysno, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                NautyTraces.C_LONG,
                NautyTraces.C_LONG
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern long syscall(long __sysno, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(long __sysno, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", __sysno, x1);
                }
                return (long) spreader.invokeExact(__sysno, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static int lockf(int __fd, int __cmd, long __len) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", __fd, __cmd, __len);
            }
            return (int)mh$.invokeExact(__fd, __cmd, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdatasync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdatasync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static FunctionDescriptor fdatasync$descriptor() {
        return fdatasync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static MethodHandle fdatasync$handle() {
        return fdatasync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static MemorySegment fdatasync$address() {
        return fdatasync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static int fdatasync(int __fildes) {
        var mh$ = fdatasync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdatasync", __fildes);
            }
            return (int)mh$.invokeExact(__fildes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MemorySegment crypt(MemorySegment __key, MemorySegment __salt) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", __key, __salt);
            }
            return (MemorySegment)mh$.invokeExact(__key, __salt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getentropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getentropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static FunctionDescriptor getentropy$descriptor() {
        return getentropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static MethodHandle getentropy$handle() {
        return getentropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static MemorySegment getentropy$address() {
        return getentropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static int getentropy(MemorySegment __buffer, long __length) {
        var mh$ = getentropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getentropy", __buffer, __length);
            }
            return (int)mh$.invokeExact(__buffer, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = NautyTraces.C_INT;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_DOUBLE,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_DOUBLE,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_FLOAT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_DOUBLE,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = NautyTraces.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = NautyTraces.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = NautyTraces.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = NautyTraces.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = NautyTraces.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = NautyTraces.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = NautyTraces.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = NautyTraces.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = NautyTraces.C_LONG;

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = NautyTraces.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = NautyTraces.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy$address() {
        return __mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy$address() {
        return mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long setword
     * }
     */
    public static final OfLong setword = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long nauty_counter
     * }
     */
    public static final OfLong nauty_counter = NautyTraces.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int shortish
     * }
     */
    public static final OfInt shortish = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int permutation
     * }
     */
    public static final OfInt permutation = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int nvector
     * }
     */
    public static final OfInt nvector = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int np2vector
     * }
     */
    public static final OfInt np2vector = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int boolean
     * }
     */
    public static final OfInt boolean_ = NautyTraces.C_INT;
    /**
     * {@snippet lang=c :
     * typedef setword set
     * }
     */
    public static final OfLong set = NautyTraces.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef setword graph
     * }
     */
    public static final OfLong graph = NautyTraces.C_LONG;

    private static class alloc_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloc_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static FunctionDescriptor alloc_error$descriptor() {
        return alloc_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static MethodHandle alloc_error$handle() {
        return alloc_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static MemorySegment alloc_error$address() {
        return alloc_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void alloc_error(const char *)
     * }
     */
    public static void alloc_error(MemorySegment x0) {
        var mh$ = alloc_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloc_error", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class breakout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("breakout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static FunctionDescriptor breakout$descriptor() {
        return breakout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static MethodHandle breakout$handle() {
        return breakout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static MemorySegment breakout$address() {
        return breakout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void breakout(int *, int *, int, int, int, set *, int)
     * }
     */
    public static void breakout(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, MemorySegment x5, int x6) {
        var mh$ = breakout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("breakout", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheapautom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cheapautom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static FunctionDescriptor cheapautom$descriptor() {
        return cheapautom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static MethodHandle cheapautom$handle() {
        return cheapautom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static MemorySegment cheapautom$address() {
        return cheapautom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean cheapautom(int *, int, boolean, int)
     * }
     */
    public static int cheapautom(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = cheapautom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheapautom", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class doref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("doref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor doref$descriptor() {
        return doref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static MethodHandle doref$handle() {
        return doref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static MemorySegment doref$address() {
        return doref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void doref(graph *, int *, int *, int, int *, int *, int *, set *, int *, void (*)(graph *, int *, int *, int, int *, int *, set *, int *, int, int), void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean, int, int)
     * }
     */
    public static void doref(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, int x11, int x12, int x13, int x14, int x15, int x16) {
        var mh$ = doref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("doref", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class extra_autom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("extra_autom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static FunctionDescriptor extra_autom$descriptor() {
        return extra_autom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static MethodHandle extra_autom$handle() {
        return extra_autom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static MemorySegment extra_autom$address() {
        return extra_autom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void extra_autom(int *, int)
     * }
     */
    public static void extra_autom(MemorySegment x0, int x1) {
        var mh$ = extra_autom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("extra_autom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class extra_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("extra_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static FunctionDescriptor extra_level$descriptor() {
        return extra_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static MethodHandle extra_level$handle() {
        return extra_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static MemorySegment extra_level$address() {
        return extra_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void extra_level(int, int *, int *, int, int, int, int, int, int)
     * }
     */
    public static void extra_level(int x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, int x6, int x7, int x8) {
        var mh$ = extra_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("extra_level", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isautom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isautom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static FunctionDescriptor isautom$descriptor() {
        return isautom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static MethodHandle isautom$handle() {
        return isautom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static MemorySegment isautom$address() {
        return isautom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean isautom(graph *, int *, boolean, int, int)
     * }
     */
    public static int isautom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = isautom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isautom", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_graph$constants {
        public static final GroupLayout LAYOUT = dispatchvec.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("dispatch_graph").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static GroupLayout dispatch_graph$layout() {
        return dispatch_graph$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static MemorySegment dispatch_graph() {
        return dispatch_graph$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_graph
     * }
     */
    public static void dispatch_graph(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, dispatch_graph$constants.SEGMENT, 0L, dispatch_graph$constants.LAYOUT.byteSize());
    }

    private static class itos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("itos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static FunctionDescriptor itos$descriptor() {
        return itos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static MethodHandle itos$handle() {
        return itos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static MemorySegment itos$address() {
        return itos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int itos(int, char *)
     * }
     */
    public static int itos(int x0, MemorySegment x1) {
        var mh$ = itos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static FunctionDescriptor fmperm$descriptor() {
        return fmperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static MethodHandle fmperm$handle() {
        return fmperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static MemorySegment fmperm$address() {
        return fmperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fmperm(const int *, set *, set *, int, int)
     * }
     */
    public static void fmperm(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4) {
        var mh$ = fmperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmperm", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static FunctionDescriptor fmptn$descriptor() {
        return fmptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static MethodHandle fmptn$handle() {
        return fmptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static MemorySegment fmptn$address() {
        return fmptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fmptn(const int *, const int *, int, set *, set *, int, int)
     * }
     */
    public static void fmptn(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, int x5, int x6) {
        var mh$ = fmptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmptn", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class longprune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("longprune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static FunctionDescriptor longprune$descriptor() {
        return longprune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static MethodHandle longprune$handle() {
        return longprune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static MemorySegment longprune$address() {
        return longprune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void longprune(set *, set *, set *, set *, int)
     * }
     */
    public static void longprune(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4) {
        var mh$ = longprune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("longprune", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static FunctionDescriptor nauty$descriptor() {
        return nauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static MethodHandle nauty$handle() {
        return nauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static MemorySegment nauty$address() {
        return nauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty(graph *, int *, int *, set *, int *, optionblk *, statsblk *, set *, int, int, int, graph *)
     * }
     */
    public static void nauty(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9, int x10, MemorySegment x11) {
        var mh$ = nauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class maketargetcell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("maketargetcell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static FunctionDescriptor maketargetcell$descriptor() {
        return maketargetcell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static MethodHandle maketargetcell$handle() {
        return maketargetcell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static MemorySegment maketargetcell$address() {
        return maketargetcell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void maketargetcell(graph *, int *, int *, int, set *, int *, int *, int, boolean, int, int (*)(graph *, int *, int *, int, int, boolean, int, int, int), int, int)
     * }
     */
    public static void maketargetcell(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7, int x8, int x9, MemorySegment x10, int x11, int x12) {
        var mh$ = maketargetcell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("maketargetcell", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextelement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextelement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static FunctionDescriptor nextelement$descriptor() {
        return nextelement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static MethodHandle nextelement$handle() {
        return nextelement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static MemorySegment nextelement$address() {
        return nextelement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nextelement(const set *, int, int)
     * }
     */
    public static int nextelement(MemorySegment x0, int x1, int x2) {
        var mh$ = nextelement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextelement", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class orbjoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("orbjoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static FunctionDescriptor orbjoin$descriptor() {
        return orbjoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static MethodHandle orbjoin$handle() {
        return orbjoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static MemorySegment orbjoin$address() {
        return orbjoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int orbjoin(int *, const int *, int)
     * }
     */
    public static int orbjoin(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = orbjoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("orbjoin", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class permset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("permset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static FunctionDescriptor permset$descriptor() {
        return permset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static MethodHandle permset$handle() {
        return permset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static MemorySegment permset$address() {
        return permset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void permset(const set *, set *, int, int *)
     * }
     */
    public static void permset(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = permset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("permset", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static FunctionDescriptor putstring$descriptor() {
        return putstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static MethodHandle putstring$handle() {
        return putstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static MemorySegment putstring$address() {
        return putstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putstring(FILE *, const char *)
     * }
     */
    public static void putstring(MemorySegment x0, MemorySegment x1) {
        var mh$ = putstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putstring", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static FunctionDescriptor refine$descriptor() {
        return refine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MethodHandle refine$handle() {
        return refine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine$address() {
        return refine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9) {
        var mh$ = refine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static FunctionDescriptor refine1$descriptor() {
        return refine1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MethodHandle refine1$handle() {
        return refine1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine1$address() {
        return refine1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine1(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine1(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9) {
        var mh$ = refine1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine1", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shortprune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("shortprune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static FunctionDescriptor shortprune$descriptor() {
        return shortprune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static MethodHandle shortprune$handle() {
        return shortprune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static MemorySegment shortprune$address() {
        return shortprune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shortprune(set *, const set *, int)
     * }
     */
    public static void shortprune(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = shortprune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shortprune", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class targetcell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("targetcell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor targetcell$descriptor() {
        return targetcell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MethodHandle targetcell$handle() {
        return targetcell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MemorySegment targetcell$address() {
        return targetcell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int targetcell(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static int targetcell(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, int x6, int x7, int x8) {
        var mh$ = targetcell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("targetcell", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class testcanlab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("testcanlab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor testcanlab$descriptor() {
        return testcanlab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MethodHandle testcanlab$handle() {
        return testcanlab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MemorySegment testcanlab$address() {
        return testcanlab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int testcanlab(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static int testcanlab(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = testcanlab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("testcanlab", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class updatecan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("updatecan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static FunctionDescriptor updatecan$descriptor() {
        return updatecan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MethodHandle updatecan$handle() {
        return updatecan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MemorySegment updatecan$address() {
        return updatecan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void updatecan(graph *, graph *, int *, int, int, int)
     * }
     */
    public static void updatecan(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = updatecan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("updatecan", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static FunctionDescriptor writeperm$descriptor() {
        return writeperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static MethodHandle writeperm$handle() {
        return writeperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static MemorySegment writeperm$address() {
        return writeperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeperm(FILE *, const int *, boolean, int, int)
     * }
     */
    public static void writeperm(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = writeperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeperm", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static FunctionDescriptor nauty_freedyn$descriptor() {
        return nauty_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static MethodHandle nauty_freedyn$handle() {
        return nauty_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static MemorySegment nauty_freedyn$address() {
        return nauty_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty_freedyn()
     * }
     */
    public static void nauty_freedyn() {
        var mh$ = nauty_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nauty_check$descriptor() {
        return nauty_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static MethodHandle nauty_check$handle() {
        return nauty_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static MemorySegment nauty_check$address() {
        return nauty_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nauty_check(int, int, int, int)
     * }
     */
    public static void nauty_check(int x0, int x1, int x2, int x3) {
        var mh$ = nauty_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naugraph_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naugraph_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor naugraph_check$descriptor() {
        return naugraph_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static MethodHandle naugraph_check$handle() {
        return naugraph_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static MemorySegment naugraph_check$address() {
        return naugraph_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naugraph_check(int, int, int, int)
     * }
     */
    public static void naugraph_check(int x0, int x1, int x2, int x3) {
        var mh$ = naugraph_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naugraph_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautil_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautil_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nautil_check$descriptor() {
        return nautil_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static MethodHandle nautil_check$handle() {
        return nautil_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static MemorySegment nautil_check$address() {
        return nautil_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautil_check(int, int, int, int)
     * }
     */
    public static void nautil_check(int x0, int x1, int x2, int x3) {
        var mh$ = nautil_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautil_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautil_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautil_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static FunctionDescriptor nautil_freedyn$descriptor() {
        return nautil_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static MethodHandle nautil_freedyn$handle() {
        return nautil_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static MemorySegment nautil_freedyn$address() {
        return nautil_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautil_freedyn()
     * }
     */
    public static void nautil_freedyn() {
        var mh$ = nautil_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautil_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naugraph_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naugraph_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static FunctionDescriptor naugraph_freedyn$descriptor() {
        return naugraph_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static MethodHandle naugraph_freedyn$handle() {
        return naugraph_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static MemorySegment naugraph_freedyn$address() {
        return naugraph_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naugraph_freedyn()
     * }
     */
    public static void naugraph_freedyn() {
        var mh$ = naugraph_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naugraph_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class densenauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("densenauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static FunctionDescriptor densenauty$descriptor() {
        return densenauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static MethodHandle densenauty$handle() {
        return densenauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static MemorySegment densenauty$address() {
        return densenauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void densenauty(graph *, int *, int *, int *, optionblk *, statsblk *, int, int, graph *)
     * }
     */
    public static void densenauty(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7, MemorySegment x8) {
        var mh$ = densenauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("densenauty", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writegroupsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_DOUBLE,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writegroupsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static FunctionDescriptor writegroupsize$descriptor() {
        return writegroupsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static MethodHandle writegroupsize$handle() {
        return writegroupsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static MemorySegment writegroupsize$address() {
        return writegroupsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writegroupsize(FILE *, double, int)
     * }
     */
    public static void writegroupsize(MemorySegment x0, double x1, int x2) {
        var mh$ = writegroupsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writegroupsize", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labelorg$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("labelorg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static OfInt labelorg$layout() {
        return labelorg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static MemorySegment labelorg$segment() {
        return labelorg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static int labelorg() {
        return labelorg$constants.SEGMENT.get(labelorg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int labelorg
     * }
     */
    public static void labelorg(int varValue) {
        labelorg$constants.SEGMENT.set(labelorg$constants.LAYOUT, 0L, varValue);
    }

    private static class nauty_kill_request$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("nauty_kill_request").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static OfInt nauty_kill_request$layout() {
        return nauty_kill_request$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static MemorySegment nauty_kill_request$segment() {
        return nauty_kill_request$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static int nauty_kill_request() {
        return nauty_kill_request$constants.SEGMENT.get(nauty_kill_request$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern volatile int nauty_kill_request
     * }
     */
    public static void nauty_kill_request(int varValue) {
        nauty_kill_request$constants.SEGMENT.set(nauty_kill_request$constants.LAYOUT, 0L, varValue);
    }

    private static class adjacencies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjacencies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor adjacencies$descriptor() {
        return adjacencies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle adjacencies$handle() {
        return adjacencies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment adjacencies$address() {
        return adjacencies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void adjacencies(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void adjacencies(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = adjacencies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjacencies", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static class adjtriang {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjtriang");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor adjtriang$descriptor() {
        return adjtriang.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle adjtriang$handle() {
        return adjtriang.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment adjtriang$address() {
        return adjtriang.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void adjtriang(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void adjtriang(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = adjtriang.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtriang", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellcliq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellcliq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellcliq$descriptor() {
        return cellcliq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellcliq$handle() {
        return cellcliq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellcliq$address() {
        return cellcliq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellcliq(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellcliq(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellcliq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellcliq", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellfano {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellfano");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellfano$descriptor() {
        return cellfano.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellfano$handle() {
        return cellfano.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellfano$address() {
        return cellfano.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellfano(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellfano(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellfano.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellfano", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellfano2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellfano2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellfano2$descriptor() {
        return cellfano2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellfano2$handle() {
        return cellfano2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellfano2$address() {
        return cellfano2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellfano2(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellfano2(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellfano2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellfano2", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellind$descriptor() {
        return cellind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellind$handle() {
        return cellind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellind$address() {
        return cellind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellind(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellind(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellind", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellquads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellquads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellquads$descriptor() {
        return cellquads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellquads$handle() {
        return cellquads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellquads$address() {
        return cellquads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellquads(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellquads(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellquads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellquads", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellquins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellquins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cellquins$descriptor() {
        return cellquins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cellquins$handle() {
        return cellquins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cellquins$address() {
        return cellquins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellquins(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cellquins(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cellquins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellquins", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class celltrips {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("celltrips");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor celltrips$descriptor() {
        return celltrips.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle celltrips$handle() {
        return celltrips.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment celltrips$address() {
        return celltrips.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void celltrips(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void celltrips(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = celltrips.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("celltrips", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cellstarts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cellstarts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static FunctionDescriptor cellstarts$descriptor() {
        return cellstarts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static MethodHandle cellstarts$handle() {
        return cellstarts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static MemorySegment cellstarts$address() {
        return cellstarts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cellstarts(int *, int, set *, int, int)
     * }
     */
    public static void cellstarts(MemorySegment x0, int x1, MemorySegment x2, int x3, int x4) {
        var mh$ = cellstarts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cellstarts", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor cliques$descriptor() {
        return cliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle cliques$handle() {
        return cliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment cliques$address() {
        return cliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cliques(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void cliques(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = cliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cliques", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class distances {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("distances");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor distances$descriptor() {
        return distances.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle distances$handle() {
        return distances.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment distances$address() {
        return distances.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void distances(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void distances(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = distances.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("distances", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbigcells {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getbigcells");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static FunctionDescriptor getbigcells$descriptor() {
        return getbigcells.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static MethodHandle getbigcells$handle() {
        return getbigcells.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static MemorySegment getbigcells$address() {
        return getbigcells.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void getbigcells(int *, int, int, int *, int *, int *, int)
     * }
     */
    public static void getbigcells(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = getbigcells.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbigcells", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class indsets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("indsets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor indsets$descriptor() {
        return indsets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle indsets$handle() {
        return indsets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment indsets$address() {
        return indsets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void indsets(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void indsets(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = indsets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("indsets", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautinv_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautinv_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nautinv_check$descriptor() {
        return nautinv_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static MethodHandle nautinv_check$handle() {
        return nautinv_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static MemorySegment nautinv_check$address() {
        return nautinv_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautinv_check(int, int, int, int)
     * }
     */
    public static void nautinv_check(int x0, int x1, int x2, int x3) {
        var mh$ = nautinv_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautinv_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nautinv_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nautinv_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static FunctionDescriptor nautinv_freedyn$descriptor() {
        return nautinv_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static MethodHandle nautinv_freedyn$handle() {
        return nautinv_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static MemorySegment nautinv_freedyn$address() {
        return nautinv_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nautinv_freedyn()
     * }
     */
    public static void nautinv_freedyn() {
        var mh$ = nautinv_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nautinv_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quadruples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quadruples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor quadruples$descriptor() {
        return quadruples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle quadruples$handle() {
        return quadruples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment quadruples$address() {
        return quadruples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quadruples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void quadruples(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = quadruples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quadruples", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refinvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refinvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor refinvar$descriptor() {
        return refinvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle refinvar$handle() {
        return refinvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment refinvar$address() {
        return refinvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refinvar(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void refinvar(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = refinvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refinvar", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setnbhd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setnbhd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static FunctionDescriptor setnbhd$descriptor() {
        return setnbhd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static MethodHandle setnbhd$handle() {
        return setnbhd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static MemorySegment setnbhd$address() {
        return setnbhd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setnbhd(graph *, int, int, set *, set *)
     * }
     */
    public static void setnbhd(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = setnbhd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setnbhd", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class triples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("triples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor triples$descriptor() {
        return triples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle triples$handle() {
        return triples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment triples$address() {
        return triples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void triples(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void triples(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = triples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("triples", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class twopaths {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("twopaths");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor twopaths$descriptor() {
        return twopaths.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle twopaths$handle() {
        return twopaths.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment twopaths$address() {
        return twopaths.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void twopaths(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void twopaths(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = twopaths.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("twopaths", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int sg_weight
     * }
     */
    public static final OfInt sg_weight = NautyTraces.C_INT;

    private static class dispatch_sparse$constants {
        public static final GroupLayout LAYOUT = dispatchvec.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("dispatch_sparse").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_sparse
     * }
     */
    public static GroupLayout dispatch_sparse$layout() {
        return dispatch_sparse$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_sparse
     * }
     */
    public static MemorySegment dispatch_sparse() {
        return dispatch_sparse$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern dispatchvec dispatch_sparse
     * }
     */
    public static void dispatch_sparse(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, dispatch_sparse$constants.SEGMENT, 0L, dispatch_sparse$constants.LAYOUT.byteSize());
    }

    private static class targetcell_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("targetcell_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int targetcell_sg(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor targetcell_sg$descriptor() {
        return targetcell_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int targetcell_sg(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MethodHandle targetcell_sg$handle() {
        return targetcell_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int targetcell_sg(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static MemorySegment targetcell_sg$address() {
        return targetcell_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int targetcell_sg(graph *, int *, int *, int, int, boolean, int, int, int)
     * }
     */
    public static int targetcell_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, int x6, int x7, int x8) {
        var mh$ = targetcell_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("targetcell_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheapautom_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cheapautom_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean cheapautom_sg(int *, int, boolean, int)
     * }
     */
    public static FunctionDescriptor cheapautom_sg$descriptor() {
        return cheapautom_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean cheapautom_sg(int *, int, boolean, int)
     * }
     */
    public static MethodHandle cheapautom_sg$handle() {
        return cheapautom_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean cheapautom_sg(int *, int, boolean, int)
     * }
     */
    public static MemorySegment cheapautom_sg$address() {
        return cheapautom_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean cheapautom_sg(int *, int, boolean, int)
     * }
     */
    public static int cheapautom_sg(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = cheapautom_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheapautom_sg", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isautom_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isautom_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean isautom_sg(graph *, int *, boolean, int, int)
     * }
     */
    public static FunctionDescriptor isautom_sg$descriptor() {
        return isautom_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean isautom_sg(graph *, int *, boolean, int, int)
     * }
     */
    public static MethodHandle isautom_sg$handle() {
        return isautom_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean isautom_sg(graph *, int *, boolean, int, int)
     * }
     */
    public static MemorySegment isautom_sg$address() {
        return isautom_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean isautom_sg(graph *, int *, boolean, int, int)
     * }
     */
    public static int isautom_sg(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = isautom_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isautom_sg", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine_sg(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static FunctionDescriptor refine_sg$descriptor() {
        return refine_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine_sg(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MethodHandle refine_sg$handle() {
        return refine_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine_sg(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static MemorySegment refine_sg$address() {
        return refine_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine_sg(graph *, int *, int *, int, int *, int *, set *, int *, int, int)
     * }
     */
    public static void refine_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, int x9) {
        var mh$ = refine_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class testcanlab_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("testcanlab_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int testcanlab_sg(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor testcanlab_sg$descriptor() {
        return testcanlab_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int testcanlab_sg(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MethodHandle testcanlab_sg$handle() {
        return testcanlab_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int testcanlab_sg(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static MemorySegment testcanlab_sg$address() {
        return testcanlab_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int testcanlab_sg(graph *, graph *, int *, int *, int, int)
     * }
     */
    public static int testcanlab_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = testcanlab_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("testcanlab_sg", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class updatecan_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("updatecan_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void updatecan_sg(graph *, graph *, int *, int, int, int)
     * }
     */
    public static FunctionDescriptor updatecan_sg$descriptor() {
        return updatecan_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void updatecan_sg(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MethodHandle updatecan_sg$handle() {
        return updatecan_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void updatecan_sg(graph *, graph *, int *, int, int, int)
     * }
     */
    public static MemorySegment updatecan_sg$address() {
        return updatecan_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void updatecan_sg(graph *, graph *, int *, int, int, int)
     * }
     */
    public static void updatecan_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = updatecan_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("updatecan_sg", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class testcanlab_tr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("testcanlab_tr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int testcanlab_tr(sparsegraph *, sparsegraph *, int *, int *, int *)
     * }
     */
    public static FunctionDescriptor testcanlab_tr$descriptor() {
        return testcanlab_tr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int testcanlab_tr(sparsegraph *, sparsegraph *, int *, int *, int *)
     * }
     */
    public static MethodHandle testcanlab_tr$handle() {
        return testcanlab_tr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int testcanlab_tr(sparsegraph *, sparsegraph *, int *, int *, int *)
     * }
     */
    public static MemorySegment testcanlab_tr$address() {
        return testcanlab_tr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int testcanlab_tr(sparsegraph *, sparsegraph *, int *, int *, int *)
     * }
     */
    public static int testcanlab_tr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = testcanlab_tr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("testcanlab_tr", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class comparelab_tr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("comparelab_tr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int comparelab_tr(sparsegraph *, int *, int *, int *, int *, int *, int *)
     * }
     */
    public static FunctionDescriptor comparelab_tr$descriptor() {
        return comparelab_tr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int comparelab_tr(sparsegraph *, int *, int *, int *, int *, int *, int *)
     * }
     */
    public static MethodHandle comparelab_tr$handle() {
        return comparelab_tr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int comparelab_tr(sparsegraph *, int *, int *, int *, int *, int *, int *)
     * }
     */
    public static MemorySegment comparelab_tr$address() {
        return comparelab_tr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int comparelab_tr(sparsegraph *, int *, int *, int *, int *, int *, int *)
     * }
     */
    public static int comparelab_tr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = comparelab_tr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("comparelab_tr", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class updatecan_tr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("updatecan_tr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void updatecan_tr(sparsegraph *, sparsegraph *, int *, int *, int)
     * }
     */
    public static FunctionDescriptor updatecan_tr$descriptor() {
        return updatecan_tr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void updatecan_tr(sparsegraph *, sparsegraph *, int *, int *, int)
     * }
     */
    public static MethodHandle updatecan_tr$handle() {
        return updatecan_tr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void updatecan_tr(sparsegraph *, sparsegraph *, int *, int *, int)
     * }
     */
    public static MemorySegment updatecan_tr$address() {
        return updatecan_tr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void updatecan_tr(sparsegraph *, sparsegraph *, int *, int *, int)
     * }
     */
    public static void updatecan_tr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4) {
        var mh$ = updatecan_tr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("updatecan_tr", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void init_sg(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static FunctionDescriptor init_sg$descriptor() {
        return init_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void init_sg(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static MethodHandle init_sg$handle() {
        return init_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void init_sg(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static MemorySegment init_sg$address() {
        return init_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void init_sg(graph *, graph **, graph *, graph **, int *, int *, set *, struct optionstruct *, int *, int, int)
     * }
     */
    public static void init_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, int x9, int x10) {
        var mh$ = init_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cleanup_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cleanup_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cleanup_sg(graph *, graph **, graph *, graph **, int *, int *, optionblk *, statsblk *stats, int, int)
     * }
     */
    public static FunctionDescriptor cleanup_sg$descriptor() {
        return cleanup_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cleanup_sg(graph *, graph **, graph *, graph **, int *, int *, optionblk *, statsblk *stats, int, int)
     * }
     */
    public static MethodHandle cleanup_sg$handle() {
        return cleanup_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cleanup_sg(graph *, graph **, graph *, graph **, int *, int *, optionblk *, statsblk *stats, int, int)
     * }
     */
    public static MemorySegment cleanup_sg$address() {
        return cleanup_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cleanup_sg(graph *, graph **, graph *, graph **, int *, int *, optionblk *, statsblk *stats, int, int)
     * }
     */
    public static void cleanup_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment stats, int x8, int x9) {
        var mh$ = cleanup_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cleanup_sg", x0, x1, x2, x3, x4, x5, x6, stats, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, stats, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nausparse_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nausparse_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nausparse_freedyn()
     * }
     */
    public static FunctionDescriptor nausparse_freedyn$descriptor() {
        return nausparse_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nausparse_freedyn()
     * }
     */
    public static MethodHandle nausparse_freedyn$handle() {
        return nausparse_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nausparse_freedyn()
     * }
     */
    public static MemorySegment nausparse_freedyn$address() {
        return nausparse_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nausparse_freedyn()
     * }
     */
    public static void nausparse_freedyn() {
        var mh$ = nausparse_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nausparse_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nausparse_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nausparse_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void nausparse_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor nausparse_check$descriptor() {
        return nausparse_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void nausparse_check(int, int, int, int)
     * }
     */
    public static MethodHandle nausparse_check$handle() {
        return nausparse_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void nausparse_check(int, int, int, int)
     * }
     */
    public static MemorySegment nausparse_check$address() {
        return nausparse_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void nausparse_check(int, int, int, int)
     * }
     */
    public static void nausparse_check(int x0, int x1, int x2, int x3) {
        var mh$ = nausparse_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nausparse_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nauty_to_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nauty_to_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *nauty_to_sg(graph *, sparsegraph *, int, int)
     * }
     */
    public static FunctionDescriptor nauty_to_sg$descriptor() {
        return nauty_to_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *nauty_to_sg(graph *, sparsegraph *, int, int)
     * }
     */
    public static MethodHandle nauty_to_sg$handle() {
        return nauty_to_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *nauty_to_sg(graph *, sparsegraph *, int, int)
     * }
     */
    public static MemorySegment nauty_to_sg$address() {
        return nauty_to_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *nauty_to_sg(graph *, sparsegraph *, int, int)
     * }
     */
    public static MemorySegment nauty_to_sg(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = nauty_to_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nauty_to_sg", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sg_to_nauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sg_to_nauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *sg_to_nauty(sparsegraph *, graph *, int, int *)
     * }
     */
    public static FunctionDescriptor sg_to_nauty$descriptor() {
        return sg_to_nauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *sg_to_nauty(sparsegraph *, graph *, int, int *)
     * }
     */
    public static MethodHandle sg_to_nauty$handle() {
        return sg_to_nauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *sg_to_nauty(sparsegraph *, graph *, int, int *)
     * }
     */
    public static MemorySegment sg_to_nauty$address() {
        return sg_to_nauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *sg_to_nauty(sparsegraph *, graph *, int, int *)
     * }
     */
    public static MemorySegment sg_to_nauty(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = sg_to_nauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sg_to_nauty", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sortlists_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sortlists_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sortlists_sg(sparsegraph *)
     * }
     */
    public static FunctionDescriptor sortlists_sg$descriptor() {
        return sortlists_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sortlists_sg(sparsegraph *)
     * }
     */
    public static MethodHandle sortlists_sg$handle() {
        return sortlists_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sortlists_sg(sparsegraph *)
     * }
     */
    public static MemorySegment sortlists_sg$address() {
        return sortlists_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sortlists_sg(sparsegraph *)
     * }
     */
    public static void sortlists_sg(MemorySegment x0) {
        var mh$ = sortlists_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sortlists_sg", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aresame_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("aresame_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean aresame_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor aresame_sg$descriptor() {
        return aresame_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean aresame_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MethodHandle aresame_sg$handle() {
        return aresame_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean aresame_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment aresame_sg$address() {
        return aresame_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean aresame_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static int aresame_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = aresame_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aresame_sg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class put_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("put_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void put_sg(FILE *, sparsegraph *, boolean, int)
     * }
     */
    public static FunctionDescriptor put_sg$descriptor() {
        return put_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void put_sg(FILE *, sparsegraph *, boolean, int)
     * }
     */
    public static MethodHandle put_sg$handle() {
        return put_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void put_sg(FILE *, sparsegraph *, boolean, int)
     * }
     */
    public static MemorySegment put_sg$address() {
        return put_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void put_sg(FILE *, sparsegraph *, boolean, int)
     * }
     */
    public static void put_sg(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = put_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("put_sg", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copy_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copy_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *copy_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor copy_sg$descriptor() {
        return copy_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *copy_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MethodHandle copy_sg$handle() {
        return copy_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *copy_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment copy_sg$address() {
        return copy_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *copy_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment copy_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = copy_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copy_sg", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class distvals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("distvals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void distvals(sparsegraph *, int, int *, int)
     * }
     */
    public static FunctionDescriptor distvals$descriptor() {
        return distvals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void distvals(sparsegraph *, int, int *, int)
     * }
     */
    public static MethodHandle distvals$handle() {
        return distvals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void distvals(sparsegraph *, int, int *, int)
     * }
     */
    public static MemorySegment distvals$address() {
        return distvals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void distvals(sparsegraph *, int, int *, int)
     * }
     */
    public static void distvals(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = distvals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("distvals", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sparsenauty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sparsenauty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sparsenauty(sparsegraph *g, int *, int *, int *, optionblk *, statsblk *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor sparsenauty$descriptor() {
        return sparsenauty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sparsenauty(sparsegraph *g, int *, int *, int *, optionblk *, statsblk *, sparsegraph *)
     * }
     */
    public static MethodHandle sparsenauty$handle() {
        return sparsenauty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sparsenauty(sparsegraph *g, int *, int *, int *, optionblk *, statsblk *, sparsegraph *)
     * }
     */
    public static MemorySegment sparsenauty$address() {
        return sparsenauty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sparsenauty(sparsegraph *g, int *, int *, int *, optionblk *, statsblk *, sparsegraph *)
     * }
     */
    public static void sparsenauty(MemorySegment g, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = sparsenauty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sparsenauty", g, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(g, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjacencies_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjacencies_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void adjacencies_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor adjacencies_sg$descriptor() {
        return adjacencies_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void adjacencies_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle adjacencies_sg$handle() {
        return adjacencies_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void adjacencies_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment adjacencies_sg$address() {
        return adjacencies_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void adjacencies_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void adjacencies_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = adjacencies_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjacencies_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class distances_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("distances_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void distances_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static FunctionDescriptor distances_sg$descriptor() {
        return distances_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void distances_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MethodHandle distances_sg$handle() {
        return distances_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void distances_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static MemorySegment distances_sg$address() {
        return distances_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void distances_sg(graph *, int *, int *, int, int, int, int *, int, boolean, int, int)
     * }
     */
    public static void distances_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6, int x7, int x8, int x9, int x10) {
        var mh$ = distances_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("distances_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ran_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ran_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ran_init(unsigned long long)
     * }
     */
    public static FunctionDescriptor ran_init$descriptor() {
        return ran_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ran_init(unsigned long long)
     * }
     */
    public static MethodHandle ran_init$handle() {
        return ran_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ran_init(unsigned long long)
     * }
     */
    public static MemorySegment ran_init$address() {
        return ran_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ran_init(unsigned long long)
     * }
     */
    public static void ran_init(long x0) {
        var mh$ = ran_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ran_init", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ran_init_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ran_init_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ran_init_2(unsigned long long, unsigned long long)
     * }
     */
    public static FunctionDescriptor ran_init_2$descriptor() {
        return ran_init_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ran_init_2(unsigned long long, unsigned long long)
     * }
     */
    public static MethodHandle ran_init_2$handle() {
        return ran_init_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ran_init_2(unsigned long long, unsigned long long)
     * }
     */
    public static MemorySegment ran_init_2$address() {
        return ran_init_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ran_init_2(unsigned long long, unsigned long long)
     * }
     */
    public static void ran_init_2(long x0, long x1) {
        var mh$ = ran_init_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ran_init_2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ran_init_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ran_init_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long ran_init_time(unsigned long long)
     * }
     */
    public static FunctionDescriptor ran_init_time$descriptor() {
        return ran_init_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long ran_init_time(unsigned long long)
     * }
     */
    public static MethodHandle ran_init_time$handle() {
        return ran_init_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long ran_init_time(unsigned long long)
     * }
     */
    public static MemorySegment ran_init_time$address() {
        return ran_init_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long ran_init_time(unsigned long long)
     * }
     */
    public static long ran_init_time(long x0) {
        var mh$ = ran_init_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ran_init_time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ran_nextran {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ran_nextran");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long ran_nextran()
     * }
     */
    public static FunctionDescriptor ran_nextran$descriptor() {
        return ran_nextran.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long ran_nextran()
     * }
     */
    public static MethodHandle ran_nextran$handle() {
        return ran_nextran.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long ran_nextran()
     * }
     */
    public static MemorySegment ran_nextran$address() {
        return ran_nextran.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long ran_nextran()
     * }
     */
    public static long ran_nextran() {
        var mh$ = ran_nextran.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ran_nextran");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class complement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("complement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void complement(graph *, int, int)
     * }
     */
    public static FunctionDescriptor complement$descriptor() {
        return complement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void complement(graph *, int, int)
     * }
     */
    public static MethodHandle complement$handle() {
        return complement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void complement(graph *, int, int)
     * }
     */
    public static MemorySegment complement$address() {
        return complement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void complement(graph *, int, int)
     * }
     */
    public static void complement(MemorySegment x0, int x1, int x2) {
        var mh$ = complement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("complement", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class converse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("converse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void converse(graph *, int, int)
     * }
     */
    public static FunctionDescriptor converse$descriptor() {
        return converse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void converse(graph *, int, int)
     * }
     */
    public static MethodHandle converse$handle() {
        return converse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void converse(graph *, int, int)
     * }
     */
    public static MemorySegment converse$address() {
        return converse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void converse(graph *, int, int)
     * }
     */
    public static void converse(MemorySegment x0, int x1, int x2) {
        var mh$ = converse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("converse", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class converse_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("converse_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void converse_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor converse_sg$descriptor() {
        return converse_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void converse_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MethodHandle converse_sg$handle() {
        return converse_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void converse_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment converse_sg$address() {
        return converse_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void converse_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static void converse_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = converse_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("converse_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copycomment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copycomment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void copycomment(FILE *, FILE *, int)
     * }
     */
    public static FunctionDescriptor copycomment$descriptor() {
        return copycomment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void copycomment(FILE *, FILE *, int)
     * }
     */
    public static MethodHandle copycomment$handle() {
        return copycomment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void copycomment(FILE *, FILE *, int)
     * }
     */
    public static MemorySegment copycomment$address() {
        return copycomment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void copycomment(FILE *, FILE *, int)
     * }
     */
    public static void copycomment(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = copycomment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copycomment", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class complement_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("complement_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void complement_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor complement_sg$descriptor() {
        return complement_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void complement_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MethodHandle complement_sg$handle() {
        return complement_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void complement_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment complement_sg$address() {
        return complement_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void complement_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static void complement_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = complement_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("complement_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class countcells {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("countcells");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int countcells(int *, int, int)
     * }
     */
    public static FunctionDescriptor countcells$descriptor() {
        return countcells.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int countcells(int *, int, int)
     * }
     */
    public static MethodHandle countcells$handle() {
        return countcells.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int countcells(int *, int, int)
     * }
     */
    public static MemorySegment countcells$address() {
        return countcells.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int countcells(int *, int, int)
     * }
     */
    public static int countcells(MemorySegment x0, int x1, int x2) {
        var mh$ = countcells.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("countcells", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flushline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flushline(FILE *)
     * }
     */
    public static FunctionDescriptor flushline$descriptor() {
        return flushline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flushline(FILE *)
     * }
     */
    public static MethodHandle flushline$handle() {
        return flushline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flushline(FILE *)
     * }
     */
    public static MemorySegment flushline$address() {
        return flushline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flushline(FILE *)
     * }
     */
    public static void flushline(MemorySegment x0) {
        var mh$ = flushline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushline", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fixit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fixit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fixit(int *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor fixit$descriptor() {
        return fixit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fixit(int *, int *, int *, int, int)
     * }
     */
    public static MethodHandle fixit$handle() {
        return fixit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fixit(int *, int *, int *, int, int)
     * }
     */
    public static MemorySegment fixit$address() {
        return fixit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fixit(int *, int *, int *, int, int)
     * }
     */
    public static void fixit(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4) {
        var mh$ = fixit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fixit", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getint(FILE *)
     * }
     */
    public static FunctionDescriptor getint$descriptor() {
        return getint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getint(FILE *)
     * }
     */
    public static MethodHandle getint$handle() {
        return getint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getint(FILE *)
     * }
     */
    public static MemorySegment getint$address() {
        return getint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getint(FILE *)
     * }
     */
    public static int getint(MemorySegment x0) {
        var mh$ = getint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getint", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getint_sl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getint_sl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getint_sl(FILE *)
     * }
     */
    public static FunctionDescriptor getint_sl$descriptor() {
        return getint_sl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getint_sl(FILE *)
     * }
     */
    public static MethodHandle getint_sl$handle() {
        return getint_sl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getint_sl(FILE *)
     * }
     */
    public static MemorySegment getint_sl$address() {
        return getint_sl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getint_sl(FILE *)
     * }
     */
    public static int getint_sl(MemorySegment x0) {
        var mh$ = getint_sl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getint_sl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long hash(set *, long, int)
     * }
     */
    public static FunctionDescriptor hash$descriptor() {
        return hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long hash(set *, long, int)
     * }
     */
    public static MethodHandle hash$handle() {
        return hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long hash(set *, long, int)
     * }
     */
    public static MemorySegment hash$address() {
        return hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long hash(set *, long, int)
     * }
     */
    public static long hash(MemorySegment x0, long x1, int x2) {
        var mh$ = hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hash", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hashgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hashgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long hashgraph(graph *, int, int, long)
     * }
     */
    public static FunctionDescriptor hashgraph$descriptor() {
        return hashgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long hashgraph(graph *, int, int, long)
     * }
     */
    public static MethodHandle hashgraph$handle() {
        return hashgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long hashgraph(graph *, int, int, long)
     * }
     */
    public static MemorySegment hashgraph$address() {
        return hashgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long hashgraph(graph *, int, int, long)
     * }
     */
    public static long hashgraph(MemorySegment x0, int x1, int x2, long x3) {
        var mh$ = hashgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hashgraph", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hashgraph_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hashgraph_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long hashgraph_sg(sparsegraph *, long)
     * }
     */
    public static FunctionDescriptor hashgraph_sg$descriptor() {
        return hashgraph_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long hashgraph_sg(sparsegraph *, long)
     * }
     */
    public static MethodHandle hashgraph_sg$handle() {
        return hashgraph_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long hashgraph_sg(sparsegraph *, long)
     * }
     */
    public static MemorySegment hashgraph_sg$address() {
        return hashgraph_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long hashgraph_sg(sparsegraph *, long)
     * }
     */
    public static long hashgraph_sg(MemorySegment x0, long x1) {
        var mh$ = hashgraph_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hashgraph_sg", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class individualise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("individualise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void individualise(int *, int *, int, int, int *, int *, int)
     * }
     */
    public static FunctionDescriptor individualise$descriptor() {
        return individualise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void individualise(int *, int *, int, int, int *, int *, int)
     * }
     */
    public static MethodHandle individualise$handle() {
        return individualise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void individualise(int *, int *, int, int, int *, int *, int)
     * }
     */
    public static MemorySegment individualise$address() {
        return individualise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void individualise(int *, int *, int, int, int *, int *, int)
     * }
     */
    public static void individualise(MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = individualise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("individualise", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listhash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("listhash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long listhash(int *, int, long)
     * }
     */
    public static FunctionDescriptor listhash$descriptor() {
        return listhash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long listhash(int *, int, long)
     * }
     */
    public static MethodHandle listhash$handle() {
        return listhash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long listhash(int *, int, long)
     * }
     */
    public static MemorySegment listhash$address() {
        return listhash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long listhash(int *, int, long)
     * }
     */
    public static long listhash(MemorySegment x0, int x1, long x2) {
        var mh$ = listhash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listhash", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listtoset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("listtoset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void listtoset(int *, int, set *, int)
     * }
     */
    public static FunctionDescriptor listtoset$descriptor() {
        return listtoset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void listtoset(int *, int, set *, int)
     * }
     */
    public static MethodHandle listtoset$handle() {
        return listtoset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void listtoset(int *, int, set *, int)
     * }
     */
    public static MemorySegment listtoset$address() {
        return listtoset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void listtoset(int *, int, set *, int)
     * }
     */
    public static void listtoset(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = listtoset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listtoset", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mathon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mathon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mathon(graph *, int, int, graph *, int, int)
     * }
     */
    public static FunctionDescriptor mathon$descriptor() {
        return mathon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mathon(graph *, int, int, graph *, int, int)
     * }
     */
    public static MethodHandle mathon$handle() {
        return mathon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mathon(graph *, int, int, graph *, int, int)
     * }
     */
    public static MemorySegment mathon$address() {
        return mathon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mathon(graph *, int, int, graph *, int, int)
     * }
     */
    public static void mathon(MemorySegment x0, int x1, int x2, MemorySegment x3, int x4, int x5) {
        var mh$ = mathon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mathon", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mathon_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mathon_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mathon_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor mathon_sg$descriptor() {
        return mathon_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mathon_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MethodHandle mathon_sg$handle() {
        return mathon_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mathon_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static MemorySegment mathon_sg$address() {
        return mathon_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mathon_sg(sparsegraph *, sparsegraph *)
     * }
     */
    public static void mathon_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = mathon_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mathon_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naututil_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naututil_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naututil_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor naututil_check$descriptor() {
        return naututil_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naututil_check(int, int, int, int)
     * }
     */
    public static MethodHandle naututil_check$handle() {
        return naututil_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naututil_check(int, int, int, int)
     * }
     */
    public static MemorySegment naututil_check$address() {
        return naututil_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naututil_check(int, int, int, int)
     * }
     */
    public static void naututil_check(int x0, int x1, int x2, int x3) {
        var mh$ = naututil_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naututil_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class naututil_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("naututil_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void naututil_freedyn()
     * }
     */
    public static FunctionDescriptor naututil_freedyn$descriptor() {
        return naututil_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void naututil_freedyn()
     * }
     */
    public static MethodHandle naututil_freedyn$handle() {
        return naututil_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void naututil_freedyn()
     * }
     */
    public static MemorySegment naututil_freedyn$address() {
        return naututil_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void naututil_freedyn()
     * }
     */
    public static void naututil_freedyn() {
        var mh$ = naututil_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("naututil_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class numloops {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("numloops");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int numloops(graph *, int, int)
     * }
     */
    public static FunctionDescriptor numloops$descriptor() {
        return numloops.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int numloops(graph *, int, int)
     * }
     */
    public static MethodHandle numloops$handle() {
        return numloops.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int numloops(graph *, int, int)
     * }
     */
    public static MemorySegment numloops$address() {
        return numloops.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int numloops(graph *, int, int)
     * }
     */
    public static int numloops(MemorySegment x0, int x1, int x2) {
        var mh$ = numloops.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("numloops", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class numloops_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("numloops_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int numloops_sg(sparsegraph *)
     * }
     */
    public static FunctionDescriptor numloops_sg$descriptor() {
        return numloops_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int numloops_sg(sparsegraph *)
     * }
     */
    public static MethodHandle numloops_sg$handle() {
        return numloops_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int numloops_sg(sparsegraph *)
     * }
     */
    public static MemorySegment numloops_sg$address() {
        return numloops_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int numloops_sg(sparsegraph *)
     * }
     */
    public static int numloops_sg(MemorySegment x0) {
        var mh$ = numloops_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("numloops_sg", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putcanon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putcanon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putcanon(FILE *, int *, graph *, int, int, int)
     * }
     */
    public static FunctionDescriptor putcanon$descriptor() {
        return putcanon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putcanon(FILE *, int *, graph *, int, int, int)
     * }
     */
    public static MethodHandle putcanon$handle() {
        return putcanon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putcanon(FILE *, int *, graph *, int, int, int)
     * }
     */
    public static MemorySegment putcanon$address() {
        return putcanon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putcanon(FILE *, int *, graph *, int, int, int)
     * }
     */
    public static void putcanon(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = putcanon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putcanon", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putcanon_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putcanon_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putcanon_sg(FILE *, int *, sparsegraph *, int)
     * }
     */
    public static FunctionDescriptor putcanon_sg$descriptor() {
        return putcanon_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putcanon_sg(FILE *, int *, sparsegraph *, int)
     * }
     */
    public static MethodHandle putcanon_sg$handle() {
        return putcanon_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putcanon_sg(FILE *, int *, sparsegraph *, int)
     * }
     */
    public static MemorySegment putcanon_sg$address() {
        return putcanon_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putcanon_sg(FILE *, int *, sparsegraph *, int)
     * }
     */
    public static void putcanon_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = putcanon_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putcanon_sg", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putdegs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putdegs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putdegs(FILE *, graph *, int, int, int)
     * }
     */
    public static FunctionDescriptor putdegs$descriptor() {
        return putdegs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putdegs(FILE *, graph *, int, int, int)
     * }
     */
    public static MethodHandle putdegs$handle() {
        return putdegs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putdegs(FILE *, graph *, int, int, int)
     * }
     */
    public static MemorySegment putdegs$address() {
        return putdegs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putdegs(FILE *, graph *, int, int, int)
     * }
     */
    public static void putdegs(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = putdegs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putdegs", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putdegs_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putdegs_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putdegs_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static FunctionDescriptor putdegs_sg$descriptor() {
        return putdegs_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putdegs_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MethodHandle putdegs_sg$handle() {
        return putdegs_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putdegs_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MemorySegment putdegs_sg$address() {
        return putdegs_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putdegs_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static void putdegs_sg(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = putdegs_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putdegs_sg", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putdegseq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putdegseq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putdegseq(FILE *, graph *, int, int, int)
     * }
     */
    public static FunctionDescriptor putdegseq$descriptor() {
        return putdegseq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putdegseq(FILE *, graph *, int, int, int)
     * }
     */
    public static MethodHandle putdegseq$handle() {
        return putdegseq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putdegseq(FILE *, graph *, int, int, int)
     * }
     */
    public static MemorySegment putdegseq$address() {
        return putdegseq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putdegseq(FILE *, graph *, int, int, int)
     * }
     */
    public static void putdegseq(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = putdegseq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putdegseq", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putdegseq_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putdegseq_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putdegseq_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static FunctionDescriptor putdegseq_sg$descriptor() {
        return putdegseq_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putdegseq_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MethodHandle putdegseq_sg$handle() {
        return putdegseq_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putdegseq_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MemorySegment putdegseq_sg$address() {
        return putdegseq_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putdegseq_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static void putdegseq_sg(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = putdegseq_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putdegseq_sg", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putgraph(FILE *, graph *, int, int, int)
     * }
     */
    public static FunctionDescriptor putgraph$descriptor() {
        return putgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putgraph(FILE *, graph *, int, int, int)
     * }
     */
    public static MethodHandle putgraph$handle() {
        return putgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putgraph(FILE *, graph *, int, int, int)
     * }
     */
    public static MemorySegment putgraph$address() {
        return putgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putgraph(FILE *, graph *, int, int, int)
     * }
     */
    public static void putgraph(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = putgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putgraph", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putgraph_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putgraph_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putgraph_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static FunctionDescriptor putgraph_sg$descriptor() {
        return putgraph_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putgraph_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MethodHandle putgraph_sg$handle() {
        return putgraph_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putgraph_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static MemorySegment putgraph_sg$address() {
        return putgraph_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putgraph_sg(FILE *, sparsegraph *, int)
     * }
     */
    public static void putgraph_sg(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = putgraph_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putgraph_sg", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putmapping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putmapping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putmapping(FILE *, int *, int, int *, int, int, int)
     * }
     */
    public static FunctionDescriptor putmapping$descriptor() {
        return putmapping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putmapping(FILE *, int *, int, int *, int, int, int)
     * }
     */
    public static MethodHandle putmapping$handle() {
        return putmapping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putmapping(FILE *, int *, int, int *, int, int, int)
     * }
     */
    public static MemorySegment putmapping$address() {
        return putmapping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putmapping(FILE *, int *, int, int *, int, int, int)
     * }
     */
    public static void putmapping(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, int x4, int x5, int x6) {
        var mh$ = putmapping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putmapping", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putorbits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putorbits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putorbits(FILE *, int *, int, int)
     * }
     */
    public static FunctionDescriptor putorbits$descriptor() {
        return putorbits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putorbits(FILE *, int *, int, int)
     * }
     */
    public static MethodHandle putorbits$handle() {
        return putorbits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putorbits(FILE *, int *, int, int)
     * }
     */
    public static MemorySegment putorbits$address() {
        return putorbits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putorbits(FILE *, int *, int, int)
     * }
     */
    public static void putorbits(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = putorbits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putorbits", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putorbitsplus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putorbitsplus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putorbitsplus(FILE *, int *, int, int)
     * }
     */
    public static FunctionDescriptor putorbitsplus$descriptor() {
        return putorbitsplus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putorbitsplus(FILE *, int *, int, int)
     * }
     */
    public static MethodHandle putorbitsplus$handle() {
        return putorbitsplus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putorbitsplus(FILE *, int *, int, int)
     * }
     */
    public static MemorySegment putorbitsplus$address() {
        return putorbitsplus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putorbitsplus(FILE *, int *, int, int)
     * }
     */
    public static void putorbitsplus(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = putorbitsplus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putorbitsplus", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putptn(FILE *, int *, int *, int, int, int)
     * }
     */
    public static FunctionDescriptor putptn$descriptor() {
        return putptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putptn(FILE *, int *, int *, int, int, int)
     * }
     */
    public static MethodHandle putptn$handle() {
        return putptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putptn(FILE *, int *, int *, int, int, int)
     * }
     */
    public static MemorySegment putptn$address() {
        return putptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putptn(FILE *, int *, int *, int, int, int)
     * }
     */
    public static void putptn(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = putptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putptn", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putquotient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putquotient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putquotient(FILE *, graph *, int *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor putquotient$descriptor() {
        return putquotient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putquotient(FILE *, graph *, int *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle putquotient$handle() {
        return putquotient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putquotient(FILE *, graph *, int *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment putquotient$address() {
        return putquotient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putquotient(FILE *, graph *, int *, int *, int, int, int, int)
     * }
     */
    public static void putquotient(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5, int x6, int x7) {
        var mh$ = putquotient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putquotient", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putquotient_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putquotient_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putquotient_sg(FILE *, sparsegraph *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor putquotient_sg$descriptor() {
        return putquotient_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putquotient_sg(FILE *, sparsegraph *, int *, int *, int, int)
     * }
     */
    public static MethodHandle putquotient_sg$handle() {
        return putquotient_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putquotient_sg(FILE *, sparsegraph *, int *, int *, int, int)
     * }
     */
    public static MemorySegment putquotient_sg$address() {
        return putquotient_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putquotient_sg(FILE *, sparsegraph *, int *, int *, int, int)
     * }
     */
    public static void putquotient_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = putquotient_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putquotient_sg", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putset(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static FunctionDescriptor putset$descriptor() {
        return putset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putset(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static MethodHandle putset$handle() {
        return putset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putset(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static MemorySegment putset$address() {
        return putset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putset(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static void putset(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = putset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putset", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putset_firstbold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putset_firstbold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void putset_firstbold(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static FunctionDescriptor putset_firstbold$descriptor() {
        return putset_firstbold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void putset_firstbold(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static MethodHandle putset_firstbold$handle() {
        return putset_firstbold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void putset_firstbold(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static MemorySegment putset_firstbold$address() {
        return putset_firstbold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void putset_firstbold(FILE *, set *, int *, int, int, boolean)
     * }
     */
    public static void putset_firstbold(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, int x5) {
        var mh$ = putset_firstbold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putset_firstbold", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rangraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rangraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rangraph(graph *, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor rangraph$descriptor() {
        return rangraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rangraph(graph *, boolean, int, int, int)
     * }
     */
    public static MethodHandle rangraph$handle() {
        return rangraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rangraph(graph *, boolean, int, int, int)
     * }
     */
    public static MemorySegment rangraph$address() {
        return rangraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rangraph(graph *, boolean, int, int, int)
     * }
     */
    public static void rangraph(MemorySegment x0, int x1, int x2, int x3, int x4) {
        var mh$ = rangraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rangraph", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rangraph2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rangraph2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rangraph2(graph *, boolean, int, int, int, int)
     * }
     */
    public static FunctionDescriptor rangraph2$descriptor() {
        return rangraph2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rangraph2(graph *, boolean, int, int, int, int)
     * }
     */
    public static MethodHandle rangraph2$handle() {
        return rangraph2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rangraph2(graph *, boolean, int, int, int, int)
     * }
     */
    public static MemorySegment rangraph2$address() {
        return rangraph2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rangraph2(graph *, boolean, int, int, int, int)
     * }
     */
    public static void rangraph2(MemorySegment x0, int x1, int x2, int x3, int x4, int x5) {
        var mh$ = rangraph2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rangraph2", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rangraph2_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rangraph2_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rangraph2_sg(sparsegraph *, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor rangraph2_sg$descriptor() {
        return rangraph2_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rangraph2_sg(sparsegraph *, boolean, int, int, int)
     * }
     */
    public static MethodHandle rangraph2_sg$handle() {
        return rangraph2_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rangraph2_sg(sparsegraph *, boolean, int, int, int)
     * }
     */
    public static MemorySegment rangraph2_sg$address() {
        return rangraph2_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rangraph2_sg(sparsegraph *, boolean, int, int, int)
     * }
     */
    public static void rangraph2_sg(MemorySegment x0, int x1, int x2, int x3, int x4) {
        var mh$ = rangraph2_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rangraph2_sg", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ranreg_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ranreg_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ranreg_sg(sparsegraph *sg, int degree, int n)
     * }
     */
    public static FunctionDescriptor ranreg_sg$descriptor() {
        return ranreg_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ranreg_sg(sparsegraph *sg, int degree, int n)
     * }
     */
    public static MethodHandle ranreg_sg$handle() {
        return ranreg_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ranreg_sg(sparsegraph *sg, int degree, int n)
     * }
     */
    public static MemorySegment ranreg_sg$address() {
        return ranreg_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ranreg_sg(sparsegraph *sg, int degree, int n)
     * }
     */
    public static void ranreg_sg(MemorySegment sg, int degree, int n) {
        var mh$ = ranreg_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ranreg_sg", sg, degree, n);
            }
            mh$.invokeExact(sg, degree, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ranperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ranperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ranperm(int *, int)
     * }
     */
    public static FunctionDescriptor ranperm$descriptor() {
        return ranperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ranperm(int *, int)
     * }
     */
    public static MethodHandle ranperm$handle() {
        return ranperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ranperm(int *, int)
     * }
     */
    public static MemorySegment ranperm$address() {
        return ranperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ranperm(int *, int)
     * }
     */
    public static void ranperm(MemorySegment x0, int x1) {
        var mh$ = ranperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ranperm", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readcoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readcoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean readcoded(FILE *, boolean, boolean, graph **, sparsegraph *, boolean *, int *)
     * }
     */
    public static FunctionDescriptor readcoded$descriptor() {
        return readcoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean readcoded(FILE *, boolean, boolean, graph **, sparsegraph *, boolean *, int *)
     * }
     */
    public static MethodHandle readcoded$handle() {
        return readcoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean readcoded(FILE *, boolean, boolean, graph **, sparsegraph *, boolean *, int *)
     * }
     */
    public static MemorySegment readcoded$address() {
        return readcoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean readcoded(FILE *, boolean, boolean, graph **, sparsegraph *, boolean *, int *)
     * }
     */
    public static int readcoded(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = readcoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readcoded", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readgraph(FILE *, graph *, boolean, boolean, boolean, int, int, int)
     * }
     */
    public static FunctionDescriptor readgraph$descriptor() {
        return readgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readgraph(FILE *, graph *, boolean, boolean, boolean, int, int, int)
     * }
     */
    public static MethodHandle readgraph$handle() {
        return readgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readgraph(FILE *, graph *, boolean, boolean, boolean, int, int, int)
     * }
     */
    public static MemorySegment readgraph$address() {
        return readgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readgraph(FILE *, graph *, boolean, boolean, boolean, int, int, int)
     * }
     */
    public static void readgraph(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5, int x6, int x7) {
        var mh$ = readgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readgraph", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readgraph_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readgraph_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readgraph_sg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static FunctionDescriptor readgraph_sg$descriptor() {
        return readgraph_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readgraph_sg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static MethodHandle readgraph_sg$handle() {
        return readgraph_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readgraph_sg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static MemorySegment readgraph_sg$address() {
        return readgraph_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readgraph_sg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static void readgraph_sg(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = readgraph_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readgraph_sg", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readgraph_swg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readgraph_swg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readgraph_swg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static FunctionDescriptor readgraph_swg$descriptor() {
        return readgraph_swg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readgraph_swg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static MethodHandle readgraph_swg$handle() {
        return readgraph_swg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readgraph_swg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static MemorySegment readgraph_swg$address() {
        return readgraph_swg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readgraph_swg(FILE *, sparsegraph *, boolean, boolean, int, int)
     * }
     */
    public static void readgraph_swg(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = readgraph_swg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readgraph_swg", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readinteger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean readinteger(FILE *, int *)
     * }
     */
    public static FunctionDescriptor readinteger$descriptor() {
        return readinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean readinteger(FILE *, int *)
     * }
     */
    public static MethodHandle readinteger$handle() {
        return readinteger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean readinteger(FILE *, int *)
     * }
     */
    public static MemorySegment readinteger$address() {
        return readinteger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean readinteger(FILE *, int *)
     * }
     */
    public static int readinteger(MemorySegment x0, MemorySegment x1) {
        var mh$ = readinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readinteger", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readinteger_sl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readinteger_sl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean readinteger_sl(FILE *, int *)
     * }
     */
    public static FunctionDescriptor readinteger_sl$descriptor() {
        return readinteger_sl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean readinteger_sl(FILE *, int *)
     * }
     */
    public static MethodHandle readinteger_sl$handle() {
        return readinteger_sl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean readinteger_sl(FILE *, int *)
     * }
     */
    public static MemorySegment readinteger_sl$address() {
        return readinteger_sl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean readinteger_sl(FILE *, int *)
     * }
     */
    public static int readinteger_sl(MemorySegment x0, MemorySegment x1) {
        var mh$ = readinteger_sl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readinteger_sl", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readperm(FILE *, int *, boolean, int)
     * }
     */
    public static FunctionDescriptor readperm$descriptor() {
        return readperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readperm(FILE *, int *, boolean, int)
     * }
     */
    public static MethodHandle readperm$handle() {
        return readperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readperm(FILE *, int *, boolean, int)
     * }
     */
    public static MemorySegment readperm$address() {
        return readperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readperm(FILE *, int *, boolean, int)
     * }
     */
    public static void readperm(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = readperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readperm", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readptn(FILE *, int *, int *, int *, boolean, int)
     * }
     */
    public static FunctionDescriptor readptn$descriptor() {
        return readptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readptn(FILE *, int *, int *, int *, boolean, int)
     * }
     */
    public static MethodHandle readptn$handle() {
        return readptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readptn(FILE *, int *, int *, int *, boolean, int)
     * }
     */
    public static MemorySegment readptn$address() {
        return readptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readptn(FILE *, int *, int *, int *, boolean, int)
     * }
     */
    public static void readptn(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = readptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readptn", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readvperm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readvperm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void readvperm(FILE *, int *, boolean, int, int *)
     * }
     */
    public static FunctionDescriptor readvperm$descriptor() {
        return readvperm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void readvperm(FILE *, int *, boolean, int, int *)
     * }
     */
    public static MethodHandle readvperm$handle() {
        return readvperm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void readvperm(FILE *, int *, boolean, int, int *)
     * }
     */
    public static MemorySegment readvperm$address() {
        return readvperm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void readvperm(FILE *, int *, boolean, int, int *)
     * }
     */
    public static void readvperm(MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4) {
        var mh$ = readvperm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readvperm", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean readstring(FILE *, char *, int)
     * }
     */
    public static FunctionDescriptor readstring$descriptor() {
        return readstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean readstring(FILE *, char *, int)
     * }
     */
    public static MethodHandle readstring$handle() {
        return readstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean readstring(FILE *, char *, int)
     * }
     */
    public static MemorySegment readstring$address() {
        return readstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean readstring(FILE *, char *, int)
     * }
     */
    public static int readstring(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = readstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readstring", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class relabel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("relabel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void relabel(graph *, int *, int *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor relabel$descriptor() {
        return relabel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void relabel(graph *, int *, int *, graph *, int, int)
     * }
     */
    public static MethodHandle relabel$handle() {
        return relabel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void relabel(graph *, int *, int *, graph *, int, int)
     * }
     */
    public static MemorySegment relabel$address() {
        return relabel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void relabel(graph *, int *, int *, graph *, int, int)
     * }
     */
    public static void relabel(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = relabel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("relabel", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class relabel_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("relabel_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void relabel_sg(sparsegraph *, int *, int *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor relabel_sg$descriptor() {
        return relabel_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void relabel_sg(sparsegraph *, int *, int *, sparsegraph *)
     * }
     */
    public static MethodHandle relabel_sg$handle() {
        return relabel_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void relabel_sg(sparsegraph *, int *, int *, sparsegraph *)
     * }
     */
    public static MemorySegment relabel_sg$address() {
        return relabel_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void relabel_sg(sparsegraph *, int *, int *, sparsegraph *)
     * }
     */
    public static void relabel_sg(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = relabel_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("relabel_sg", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sethash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sethash(set *, int, long, int)
     * }
     */
    public static FunctionDescriptor sethash$descriptor() {
        return sethash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sethash(set *, int, long, int)
     * }
     */
    public static MethodHandle sethash$handle() {
        return sethash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sethash(set *, int, long, int)
     * }
     */
    public static MemorySegment sethash$address() {
        return sethash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sethash(set *, int, long, int)
     * }
     */
    public static long sethash(MemorySegment x0, int x1, long x2, int x3) {
        var mh$ = sethash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethash", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long setinter(set *, set *, int)
     * }
     */
    public static FunctionDescriptor setinter$descriptor() {
        return setinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long setinter(set *, set *, int)
     * }
     */
    public static MethodHandle setinter$handle() {
        return setinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long setinter(set *, set *, int)
     * }
     */
    public static MemorySegment setinter$address() {
        return setinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long setinter(set *, set *, int)
     * }
     */
    public static long setinter(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = setinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setinter", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long setsize(set *, int)
     * }
     */
    public static FunctionDescriptor setsize$descriptor() {
        return setsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long setsize(set *, int)
     * }
     */
    public static MethodHandle setsize$handle() {
        return setsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long setsize(set *, int)
     * }
     */
    public static MemorySegment setsize$address() {
        return setsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long setsize(set *, int)
     * }
     */
    public static long setsize(MemorySegment x0, int x1) {
        var mh$ = setsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsize", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settolist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("settolist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int settolist(set *set1, int m, int *list)
     * }
     */
    public static FunctionDescriptor settolist$descriptor() {
        return settolist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int settolist(set *set1, int m, int *list)
     * }
     */
    public static MethodHandle settolist$handle() {
        return settolist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int settolist(set *set1, int m, int *list)
     * }
     */
    public static MemorySegment settolist$address() {
        return settolist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int settolist(set *set1, int m, int *list)
     * }
     */
    public static int settolist(MemorySegment set1, int m, MemorySegment list) {
        var mh$ = settolist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settolist", set1, m, list);
            }
            return (int)mh$.invokeExact(set1, m, list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sublabel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sublabel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sublabel(graph *, int *, int, graph *, int, int)
     * }
     */
    public static FunctionDescriptor sublabel$descriptor() {
        return sublabel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sublabel(graph *, int *, int, graph *, int, int)
     * }
     */
    public static MethodHandle sublabel$handle() {
        return sublabel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sublabel(graph *, int *, int, graph *, int, int)
     * }
     */
    public static MemorySegment sublabel$address() {
        return sublabel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sublabel(graph *, int *, int, graph *, int, int)
     * }
     */
    public static void sublabel(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, int x4, int x5) {
        var mh$ = sublabel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sublabel", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sublabel_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sublabel_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sublabel_sg(sparsegraph *, int *, int, sparsegraph *)
     * }
     */
    public static FunctionDescriptor sublabel_sg$descriptor() {
        return sublabel_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sublabel_sg(sparsegraph *, int *, int, sparsegraph *)
     * }
     */
    public static MethodHandle sublabel_sg$handle() {
        return sublabel_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sublabel_sg(sparsegraph *, int *, int, sparsegraph *)
     * }
     */
    public static MemorySegment sublabel_sg$address() {
        return sublabel_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sublabel_sg(sparsegraph *, int *, int, sparsegraph *)
     * }
     */
    public static void sublabel_sg(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = sublabel_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sublabel_sg", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class subpartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("subpartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int subpartition(int *, int *, int, int *, int)
     * }
     */
    public static FunctionDescriptor subpartition$descriptor() {
        return subpartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int subpartition(int *, int *, int, int *, int)
     * }
     */
    public static MethodHandle subpartition$handle() {
        return subpartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int subpartition(int *, int *, int, int *, int)
     * }
     */
    public static MemorySegment subpartition$address() {
        return subpartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int subpartition(int *, int *, int, int *, int)
     * }
     */
    public static int subpartition(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = subpartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("subpartition", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unitptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unitptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void unitptn(int *, int *, int *, int)
     * }
     */
    public static FunctionDescriptor unitptn$descriptor() {
        return unitptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void unitptn(int *, int *, int *, int)
     * }
     */
    public static MethodHandle unitptn$handle() {
        return unitptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void unitptn(int *, int *, int *, int)
     * }
     */
    public static MemorySegment unitptn$address() {
        return unitptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void unitptn(int *, int *, int *, int)
     * }
     */
    public static void unitptn(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = unitptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unitptn", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_DOUBLE,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, NautyTraces.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = NautyTraces.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, NautyTraces.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = NautyTraces.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static int gettimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static int settimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static int adjtime(MemorySegment __delta, MemorySegment __olddelta) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", __delta, __olddelta);
            }
            return (int)mh$.invokeExact(__delta, __olddelta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ITIMER_REAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_REAL = 0
     * }
     */
    public static int ITIMER_REAL() {
        return ITIMER_REAL;
    }
    private static final int ITIMER_VIRTUAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_VIRTUAL = 1
     * }
     */
    public static int ITIMER_VIRTUAL() {
        return ITIMER_VIRTUAL;
    }
    private static final int ITIMER_PROF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_PROF = 2
     * }
     */
    public static int ITIMER_PROF() {
        return ITIMER_PROF;
    }
    /**
     * {@snippet lang=c :
     * typedef int __itimer_which_t
     * }
     */
    public static final OfInt __itimer_which_t = NautyTraces.C_INT;

    private static class getitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static int getitimer(int __which, MemorySegment __value) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", __which, __value);
            }
            return (int)mh$.invokeExact(__which, __value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static int setitimer(int __which, MemorySegment __new, MemorySegment __old) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", __which, __new, __old);
            }
            return (int)mh$.invokeExact(__which, __new, __old);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int utimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int lutimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static int futimes(int __fd, MemorySegment __tvp) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", __fd, __tvp);
            }
            return (int)mh$.invokeExact(__fd, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static FunctionDescriptor __errno_location$descriptor() {
        return __errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MethodHandle __errno_location$handle() {
        return __errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location$address() {
        return __errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location() {
        var mh$ = __errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __sig_atomic_t sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = NautyTraces.C_INT;
    private static final int SI_ASYNCNL = (int)-60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_ASYNCNL = -60
     * }
     */
    public static int SI_ASYNCNL() {
        return SI_ASYNCNL;
    }
    private static final int SI_DETHREAD = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_DETHREAD = -7
     * }
     */
    public static int SI_DETHREAD() {
        return SI_DETHREAD;
    }
    private static final int SI_TKILL = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_TKILL = -6
     * }
     */
    public static int SI_TKILL() {
        return SI_TKILL;
    }
    private static final int SI_SIGIO = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_SIGIO = -5
     * }
     */
    public static int SI_SIGIO() {
        return SI_SIGIO;
    }
    private static final int SI_ASYNCIO = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_ASYNCIO = -4
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_MESGQ = -3
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SI_TIMER = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_TIMER = -2
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_QUEUE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_QUEUE = -1
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_USER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_USER = 0
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_KERNEL = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_KERNEL = 128
     * }
     */
    public static int SI_KERNEL() {
        return SI_KERNEL;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLOPC = 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLOPN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLOPN = 2
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLADR = 3
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_ILLTRP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLTRP = 4
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_PRVOPC = 5
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_PRVREG = 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_COPROC = 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_BADSTK = 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int ILL_BADIADDR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_BADIADDR = 9
     * }
     */
    public static int ILL_BADIADDR() {
        return ILL_BADIADDR;
    }
    private static final int FPE_INTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_INTDIV = 1
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_INTOVF = 2
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int FPE_FLTDIV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTDIV = 3
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTOVF = 4
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUND = 5
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTRES = 6
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTINV = 7
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTSUB = 8
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_FLTUNK = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUNK = 14
     * }
     */
    public static int FPE_FLTUNK() {
        return FPE_FLTUNK;
    }
    private static final int FPE_CONDTRAP = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_CONDTRAP = 15
     * }
     */
    public static int FPE_CONDTRAP() {
        return FPE_CONDTRAP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MAPERR = 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCERR = 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int SEGV_BNDERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_BNDERR = 3
     * }
     */
    public static int SEGV_BNDERR() {
        return SEGV_BNDERR;
    }
    private static final int SEGV_PKUERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_PKUERR = 4
     * }
     */
    public static int SEGV_PKUERR() {
        return SEGV_PKUERR;
    }
    private static final int SEGV_ACCADI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCADI = 5
     * }
     */
    public static int SEGV_ACCADI() {
        return SEGV_ACCADI;
    }
    private static final int SEGV_ADIDERR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIDERR = 6
     * }
     */
    public static int SEGV_ADIDERR() {
        return SEGV_ADIDERR;
    }
    private static final int SEGV_ADIPERR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIPERR = 7
     * }
     */
    public static int SEGV_ADIPERR() {
        return SEGV_ADIPERR;
    }
    private static final int SEGV_MTEAERR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTEAERR = 8
     * }
     */
    public static int SEGV_MTEAERR() {
        return SEGV_MTEAERR;
    }
    private static final int SEGV_MTESERR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTESERR = 9
     * }
     */
    public static int SEGV_MTESERR() {
        return SEGV_MTESERR;
    }
    private static final int SEGV_CPERR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_CPERR = 10
     * }
     */
    public static int SEGV_CPERR() {
        return SEGV_CPERR;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRALN = 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRERR = 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_OBJERR = 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int BUS_MCEERR_AR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AR = 4
     * }
     */
    public static int BUS_MCEERR_AR() {
        return BUS_MCEERR_AR;
    }
    private static final int BUS_MCEERR_AO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AO = 5
     * }
     */
    public static int BUS_MCEERR_AO() {
        return BUS_MCEERR_AO;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_EXITED = 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_KILLED = 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_DUMPED = 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_TRAPPED = 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_STOPPED = 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_CONTINUED = 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_IN = 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_OUT = 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_MSG = 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_ERR = 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_PRI = 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_HUP = 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SIGEV_SIGNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_SIGNAL = 0
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_NONE = 1
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_THREAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD = 2
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int SIGEV_THREAD_ID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD_ID = 4
     * }
     */
    public static int SIGEV_THREAD_ID() {
        return SIGEV_THREAD_ID;
    }

    private static class __sysv_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sysv_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor __sysv_signal$descriptor() {
        return __sysv_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle __sysv_signal$handle() {
        return __sysv_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal$address() {
        return __sysv_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal(int __sig, MemorySegment __handler) {
        var mh$ = __sysv_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sysv_signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal(int __sig, MemorySegment __handler) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static FunctionDescriptor kill$descriptor() {
        return kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MethodHandle kill$handle() {
        return kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MemorySegment kill$address() {
        return kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static int kill(int __pid, int __sig) {
        var mh$ = kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kill", __pid, __sig);
            }
            return (int)mh$.invokeExact(__pid, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class killpg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("killpg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static FunctionDescriptor killpg$descriptor() {
        return killpg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MethodHandle killpg$handle() {
        return killpg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MemorySegment killpg$address() {
        return killpg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static int killpg(int __pgrp, int __sig) {
        var mh$ = killpg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("killpg", __pgrp, __sig);
            }
            return (int)mh$.invokeExact(__pgrp, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class raise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("raise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static FunctionDescriptor raise$descriptor() {
        return raise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MethodHandle raise$handle() {
        return raise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MemorySegment raise$address() {
        return raise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static int raise(int __sig) {
        var mh$ = raise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("raise", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ssignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor ssignal$descriptor() {
        return ssignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle ssignal$handle() {
        return ssignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal$address() {
        return ssignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal(int __sig, MemorySegment __handler) {
        var mh$ = ssignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssignal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static FunctionDescriptor gsignal$descriptor() {
        return gsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MethodHandle gsignal$handle() {
        return gsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MemorySegment gsignal$address() {
        return gsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static int gsignal(int __sig) {
        var mh$ = gsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gsignal", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static FunctionDescriptor psignal$descriptor() {
        return psignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MethodHandle psignal$handle() {
        return psignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MemorySegment psignal$address() {
        return psignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static void psignal(int __sig, MemorySegment __s) {
        var mh$ = psignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psignal", __sig, __s);
            }
            mh$.invokeExact(__sig, __s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psiginfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psiginfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static FunctionDescriptor psiginfo$descriptor() {
        return psiginfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MethodHandle psiginfo$handle() {
        return psiginfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MemorySegment psiginfo$address() {
        return psiginfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static void psiginfo(MemorySegment __pinfo, MemorySegment __s) {
        var mh$ = psiginfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psiginfo", __pinfo, __s);
            }
            mh$.invokeExact(__pinfo, __s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigblock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigblock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static FunctionDescriptor sigblock$descriptor() {
        return sigblock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MethodHandle sigblock$handle() {
        return sigblock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MemorySegment sigblock$address() {
        return sigblock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static int sigblock(int __mask) {
        var mh$ = sigblock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigblock", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigsetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static FunctionDescriptor sigsetmask$descriptor() {
        return sigsetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MethodHandle sigsetmask$handle() {
        return sigsetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MemorySegment sigsetmask$address() {
        return sigsetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static int sigsetmask(int __mask) {
        var mh$ = sigsetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsetmask", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class siggetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("siggetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static FunctionDescriptor siggetmask$descriptor() {
        return siggetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MethodHandle siggetmask$handle() {
        return siggetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MemorySegment siggetmask$address() {
        return siggetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static int siggetmask() {
        var mh$ = siggetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siggetmask");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigemptyset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigemptyset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigemptyset$descriptor() {
        return sigemptyset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigemptyset$handle() {
        return sigemptyset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigemptyset$address() {
        return sigemptyset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static int sigemptyset(MemorySegment __set) {
        var mh$ = sigemptyset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigemptyset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigfillset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigfillset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigfillset$descriptor() {
        return sigfillset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigfillset$handle() {
        return sigfillset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigfillset$address() {
        return sigfillset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static int sigfillset(MemorySegment __set) {
        var mh$ = sigfillset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigfillset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaddset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaddset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigaddset$descriptor() {
        return sigaddset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigaddset$handle() {
        return sigaddset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigaddset$address() {
        return sigaddset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigaddset(MemorySegment __set, int __signo) {
        var mh$ = sigaddset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaddset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigdelset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigdelset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigdelset$descriptor() {
        return sigdelset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigdelset$handle() {
        return sigdelset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigdelset$address() {
        return sigdelset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigdelset(MemorySegment __set, int __signo) {
        var mh$ = sigdelset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigdelset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigismember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigismember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigismember$descriptor() {
        return sigismember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigismember$handle() {
        return sigismember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigismember$address() {
        return sigismember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static int sigismember(MemorySegment __set, int __signo) {
        var mh$ = sigismember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigismember", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigprocmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigprocmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static FunctionDescriptor sigprocmask$descriptor() {
        return sigprocmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MethodHandle sigprocmask$handle() {
        return sigprocmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MemorySegment sigprocmask$address() {
        return sigprocmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static int sigprocmask(int __how, MemorySegment __set, MemorySegment __oset) {
        var mh$ = sigprocmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigprocmask", __how, __set, __oset);
            }
            return (int)mh$.invokeExact(__how, __set, __oset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsuspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigsuspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigsuspend$descriptor() {
        return sigsuspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MethodHandle sigsuspend$handle() {
        return sigsuspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MemorySegment sigsuspend$address() {
        return sigsuspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static int sigsuspend(MemorySegment __set) {
        var mh$ = sigsuspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsuspend", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static FunctionDescriptor sigaction$descriptor() {
        return sigaction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MethodHandle sigaction$handle() {
        return sigaction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MemorySegment sigaction$address() {
        return sigaction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static int sigaction(int __sig, MemorySegment __act, MemorySegment __oact) {
        var mh$ = sigaction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaction", __sig, __act, __oact);
            }
            return (int)mh$.invokeExact(__sig, __act, __oact);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigpending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigpending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigpending$descriptor() {
        return sigpending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MethodHandle sigpending$handle() {
        return sigpending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MemorySegment sigpending$address() {
        return sigpending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static int sigpending(MemorySegment __set) {
        var mh$ = sigpending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigpending", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static FunctionDescriptor sigwait$descriptor() {
        return sigwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MethodHandle sigwait$handle() {
        return sigwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MemorySegment sigwait$address() {
        return sigwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static int sigwait(MemorySegment __set, MemorySegment __sig) {
        var mh$ = sigwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwait", __set, __sig);
            }
            return (int)mh$.invokeExact(__set, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwaitinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigwaitinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static FunctionDescriptor sigwaitinfo$descriptor() {
        return sigwaitinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MethodHandle sigwaitinfo$handle() {
        return sigwaitinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MemorySegment sigwaitinfo$address() {
        return sigwaitinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static int sigwaitinfo(MemorySegment __set, MemorySegment __info) {
        var mh$ = sigwaitinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwaitinfo", __set, __info);
            }
            return (int)mh$.invokeExact(__set, __info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigtimedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigtimedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static FunctionDescriptor sigtimedwait$descriptor() {
        return sigtimedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MethodHandle sigtimedwait$handle() {
        return sigtimedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MemorySegment sigtimedwait$address() {
        return sigtimedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static int sigtimedwait(MemorySegment __set, MemorySegment __info, MemorySegment __timeout) {
        var mh$ = sigtimedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigtimedwait", __set, __info, __timeout);
            }
            return (int)mh$.invokeExact(__set, __info, __timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            sigval.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static FunctionDescriptor sigqueue$descriptor() {
        return sigqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MethodHandle sigqueue$handle() {
        return sigqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MemorySegment sigqueue$address() {
        return sigqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static int sigqueue(int __pid, int __sig, MemorySegment __val) {
        var mh$ = sigqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigqueue", __pid, __sig, __val);
            }
            return (int)mh$.invokeExact(__pid, __sig, __val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static FunctionDescriptor sigreturn$descriptor() {
        return sigreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MethodHandle sigreturn$handle() {
        return sigreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MemorySegment sigreturn$address() {
        return sigreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static int sigreturn(MemorySegment __scp) {
        var mh$ = sigreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigreturn", __scp);
            }
            return (int)mh$.invokeExact(__scp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long greg_t
     * }
     */
    public static final OfLong greg_t = NautyTraces.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _libc_fpstate {
     *     __uint16_t cwd;
     *     __uint16_t swd;
     *     __uint16_t ftw;
     *     __uint16_t fop;
     *     __uint64_t rip;
     *     __uint64_t rdp;
     *     __uint32_t mxcsr;
     *     __uint32_t mxcr_mask;
     *     struct _libc_fpxreg _st[8];
     *     struct _libc_xmmreg _xmm[16];
     *     __uint32_t __glibc_reserved1[24];
     * } *fpregset_t
     * }
     */
    public static final AddressLayout fpregset_t = NautyTraces.C_POINTER;

    private static class siginterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("siginterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static FunctionDescriptor siginterrupt$descriptor() {
        return siginterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MethodHandle siginterrupt$handle() {
        return siginterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MemorySegment siginterrupt$address() {
        return siginterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static int siginterrupt(int __sig, int __interrupt) {
        var mh$ = siginterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siginterrupt", __sig, __interrupt);
            }
            return (int)mh$.invokeExact(__sig, __interrupt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_ONSTACK = 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_DISABLE = 2
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }

    private static class sigaltstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaltstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static FunctionDescriptor sigaltstack$descriptor() {
        return sigaltstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MethodHandle sigaltstack$handle() {
        return sigaltstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MemorySegment sigaltstack$address() {
        return sigaltstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static int sigaltstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigaltstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaltstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static FunctionDescriptor sigstack$descriptor() {
        return sigstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MethodHandle sigstack$handle() {
        return sigstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MemorySegment sigstack$address() {
        return sigstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static int sigstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_sigmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pthread_sigmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static FunctionDescriptor pthread_sigmask$descriptor() {
        return pthread_sigmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MethodHandle pthread_sigmask$handle() {
        return pthread_sigmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MemorySegment pthread_sigmask$address() {
        return pthread_sigmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static int pthread_sigmask(int __how, MemorySegment __newmask, MemorySegment __oldmask) {
        var mh$ = pthread_sigmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_sigmask", __how, __newmask, __oldmask);
            }
            return (int)mh$.invokeExact(__how, __newmask, __oldmask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_LONG,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pthread_kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static FunctionDescriptor pthread_kill$descriptor() {
        return pthread_kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MethodHandle pthread_kill$handle() {
        return pthread_kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MemorySegment pthread_kill$address() {
        return pthread_kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static int pthread_kill(long __threadid, int __signo) {
        var mh$ = pthread_kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_kill", __threadid, __signo);
            }
            return (int)mh$.invokeExact(__threadid, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__libc_current_sigrtmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmin$descriptor() {
        return __libc_current_sigrtmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MethodHandle __libc_current_sigrtmin$handle() {
        return __libc_current_sigrtmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MemorySegment __libc_current_sigrtmin$address() {
        return __libc_current_sigrtmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static int __libc_current_sigrtmin() {
        var mh$ = __libc_current_sigrtmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmin");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__libc_current_sigrtmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmax$descriptor() {
        return __libc_current_sigrtmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MethodHandle __libc_current_sigrtmax$handle() {
        return __libc_current_sigrtmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MemorySegment __libc_current_sigrtmax$address() {
        return __libc_current_sigrtmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static int __libc_current_sigrtmax() {
        var mh$ = __libc_current_sigrtmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmax");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    private static final int P_PIDFD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PIDFD = 3
     * }
     */
    public static int P_PIDFD() {
        return P_PIDFD;
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static int wait(MemorySegment __stat_loc) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", __stat_loc);
            }
            return (int)mh$.invokeExact(__stat_loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static int waitpid(int __pid, MemorySegment __stat_loc, int __options) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", __pid, __stat_loc, __options);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static int waitid(int __idtype, int __id, MemorySegment __infop, int __options) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", __idtype, __id, __infop, __options);
            }
            return (int)mh$.invokeExact(__idtype, __id, __infop, __options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait3(MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__stat_loc, __options, __usage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait4(int __pid, MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", __pid, __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options, __usage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gtools_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gtools_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gtools_check(int, int, int, int)
     * }
     */
    public static FunctionDescriptor gtools_check$descriptor() {
        return gtools_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gtools_check(int, int, int, int)
     * }
     */
    public static MethodHandle gtools_check$handle() {
        return gtools_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gtools_check(int, int, int, int)
     * }
     */
    public static MemorySegment gtools_check$address() {
        return gtools_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gtools_check(int, int, int, int)
     * }
     */
    public static void gtools_check(int x0, int x1, int x2, int x3) {
        var mh$ = gtools_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gtools_check", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opengraphfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opengraphfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *opengraphfile(char *, int *, boolean, long)
     * }
     */
    public static FunctionDescriptor opengraphfile$descriptor() {
        return opengraphfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *opengraphfile(char *, int *, boolean, long)
     * }
     */
    public static MethodHandle opengraphfile$handle() {
        return opengraphfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *opengraphfile(char *, int *, boolean, long)
     * }
     */
    public static MemorySegment opengraphfile$address() {
        return opengraphfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *opengraphfile(char *, int *, boolean, long)
     * }
     */
    public static MemorySegment opengraphfile(MemorySegment x0, MemorySegment x1, int x2, long x3) {
        var mh$ = opengraphfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opengraphfile", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeline(FILE *, char *)
     * }
     */
    public static FunctionDescriptor writeline$descriptor() {
        return writeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeline(FILE *, char *)
     * }
     */
    public static MethodHandle writeline$handle() {
        return writeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeline(FILE *, char *)
     * }
     */
    public static MemorySegment writeline$address() {
        return writeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeline(FILE *, char *)
     * }
     */
    public static void writeline(MemorySegment x0, MemorySegment x1) {
        var mh$ = writeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeline", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gtools_getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gtools_getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gtools_getline(FILE *)
     * }
     */
    public static FunctionDescriptor gtools_getline$descriptor() {
        return gtools_getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gtools_getline(FILE *)
     * }
     */
    public static MethodHandle gtools_getline$handle() {
        return gtools_getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gtools_getline(FILE *)
     * }
     */
    public static MemorySegment gtools_getline$address() {
        return gtools_getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gtools_getline(FILE *)
     * }
     */
    public static MemorySegment gtools_getline(MemorySegment x0) {
        var mh$ = gtools_getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gtools_getline", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class graphsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("graphsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int graphsize(char *)
     * }
     */
    public static FunctionDescriptor graphsize$descriptor() {
        return graphsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int graphsize(char *)
     * }
     */
    public static MethodHandle graphsize$handle() {
        return graphsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int graphsize(char *)
     * }
     */
    public static MemorySegment graphsize$address() {
        return graphsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int graphsize(char *)
     * }
     */
    public static int graphsize(MemorySegment x0) {
        var mh$ = graphsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("graphsize", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encodegraphsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("encodegraphsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encodegraphsize(int, char **)
     * }
     */
    public static FunctionDescriptor encodegraphsize$descriptor() {
        return encodegraphsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encodegraphsize(int, char **)
     * }
     */
    public static MethodHandle encodegraphsize$handle() {
        return encodegraphsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encodegraphsize(int, char **)
     * }
     */
    public static MemorySegment encodegraphsize$address() {
        return encodegraphsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encodegraphsize(int, char **)
     * }
     */
    public static void encodegraphsize(int x0, MemorySegment x1) {
        var mh$ = encodegraphsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encodegraphsize", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stringcounts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stringcounts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stringcounts(char *, int *, size_t *)
     * }
     */
    public static FunctionDescriptor stringcounts$descriptor() {
        return stringcounts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stringcounts(char *, int *, size_t *)
     * }
     */
    public static MethodHandle stringcounts$handle() {
        return stringcounts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stringcounts(char *, int *, size_t *)
     * }
     */
    public static MemorySegment stringcounts$address() {
        return stringcounts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stringcounts(char *, int *, size_t *)
     * }
     */
    public static void stringcounts(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = stringcounts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stringcounts", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stringtograph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stringtograph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stringtograph(char *, graph *, int)
     * }
     */
    public static FunctionDescriptor stringtograph$descriptor() {
        return stringtograph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stringtograph(char *, graph *, int)
     * }
     */
    public static MethodHandle stringtograph$handle() {
        return stringtograph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stringtograph(char *, graph *, int)
     * }
     */
    public static MemorySegment stringtograph$address() {
        return stringtograph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stringtograph(char *, graph *, int)
     * }
     */
    public static void stringtograph(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = stringtograph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stringtograph", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stringtograph_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stringtograph_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stringtograph_inc(char *, graph *, int, graph *, int)
     * }
     */
    public static FunctionDescriptor stringtograph_inc$descriptor() {
        return stringtograph_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stringtograph_inc(char *, graph *, int, graph *, int)
     * }
     */
    public static MethodHandle stringtograph_inc$handle() {
        return stringtograph_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stringtograph_inc(char *, graph *, int, graph *, int)
     * }
     */
    public static MemorySegment stringtograph_inc$address() {
        return stringtograph_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stringtograph_inc(char *, graph *, int, graph *, int)
     * }
     */
    public static void stringtograph_inc(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = stringtograph_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stringtograph_inc", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class edgecount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_LONG,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("edgecount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t edgecount(char *)
     * }
     */
    public static FunctionDescriptor edgecount$descriptor() {
        return edgecount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t edgecount(char *)
     * }
     */
    public static MethodHandle edgecount$handle() {
        return edgecount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t edgecount(char *)
     * }
     */
    public static MemorySegment edgecount$address() {
        return edgecount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t edgecount(char *)
     * }
     */
    public static long edgecount(MemorySegment x0) {
        var mh$ = edgecount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("edgecount", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkgline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkgline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkgline(char *)
     * }
     */
    public static FunctionDescriptor checkgline$descriptor() {
        return checkgline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkgline(char *)
     * }
     */
    public static MethodHandle checkgline$handle() {
        return checkgline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkgline(char *)
     * }
     */
    public static MemorySegment checkgline$address() {
        return checkgline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkgline(char *)
     * }
     */
    public static int checkgline(MemorySegment x0) {
        var mh$ = checkgline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkgline", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readgg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readgg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *readgg(FILE *, graph *, int, int *, int *, boolean *)
     * }
     */
    public static FunctionDescriptor readgg$descriptor() {
        return readgg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *readgg(FILE *, graph *, int, int *, int *, boolean *)
     * }
     */
    public static MethodHandle readgg$handle() {
        return readgg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *readgg(FILE *, graph *, int, int *, int *, boolean *)
     * }
     */
    public static MemorySegment readgg$address() {
        return readgg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *readgg(FILE *, graph *, int, int *, int *, boolean *)
     * }
     */
    public static MemorySegment readgg(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = readgg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readgg", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readg_loops {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readg_loops");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *readg_loops(FILE *, graph *, int, int *, int *, int *, boolean *)
     * }
     */
    public static FunctionDescriptor readg_loops$descriptor() {
        return readg_loops.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *readg_loops(FILE *, graph *, int, int *, int *, int *, boolean *)
     * }
     */
    public static MethodHandle readg_loops$handle() {
        return readg_loops.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *readg_loops(FILE *, graph *, int, int *, int *, int *, boolean *)
     * }
     */
    public static MemorySegment readg_loops$address() {
        return readg_loops.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *readg_loops(FILE *, graph *, int, int *, int *, int *, boolean *)
     * }
     */
    public static MemorySegment readg_loops(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = readg_loops.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readg_loops", x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *readg(FILE *, graph *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor readg$descriptor() {
        return readg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *readg(FILE *, graph *, int, int *, int *)
     * }
     */
    public static MethodHandle readg$handle() {
        return readg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *readg(FILE *, graph *, int, int *, int *)
     * }
     */
    public static MemorySegment readg$address() {
        return readg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *readg(FILE *, graph *, int, int *, int *)
     * }
     */
    public static MemorySegment readg(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = readg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readg", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readgg_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readgg_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *readgg_inc(FILE *, graph *, int, int *, int *, graph *, int, int, boolean *)
     * }
     */
    public static FunctionDescriptor readgg_inc$descriptor() {
        return readgg_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *readgg_inc(FILE *, graph *, int, int *, int *, graph *, int, int, boolean *)
     * }
     */
    public static MethodHandle readgg_inc$handle() {
        return readgg_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *readgg_inc(FILE *, graph *, int, int *, int *, graph *, int, int, boolean *)
     * }
     */
    public static MemorySegment readgg_inc$address() {
        return readgg_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *readgg_inc(FILE *, graph *, int, int *, int *, graph *, int, int, boolean *)
     * }
     */
    public static MemorySegment readgg_inc(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7, MemorySegment x8) {
        var mh$ = readgg_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readgg_inc", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readg_inc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readg_inc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * graph *readg_inc(FILE *, graph *, int, int *, int *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor readg_inc$descriptor() {
        return readg_inc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * graph *readg_inc(FILE *, graph *, int, int *, int *, graph *, int, int)
     * }
     */
    public static MethodHandle readg_inc$handle() {
        return readg_inc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * graph *readg_inc(FILE *, graph *, int, int *, int *, graph *, int, int)
     * }
     */
    public static MemorySegment readg_inc$address() {
        return readg_inc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * graph *readg_inc(FILE *, graph *, int, int *, int *, graph *, int, int)
     * }
     */
    public static MemorySegment readg_inc(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7) {
        var mh$ = readg_inc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readg_inc", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntog6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntog6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ntog6(graph *, int, int)
     * }
     */
    public static FunctionDescriptor ntog6$descriptor() {
        return ntog6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ntog6(graph *, int, int)
     * }
     */
    public static MethodHandle ntog6$handle() {
        return ntog6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ntog6(graph *, int, int)
     * }
     */
    public static MemorySegment ntog6$address() {
        return ntog6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ntog6(graph *, int, int)
     * }
     */
    public static MemorySegment ntog6(MemorySegment x0, int x1, int x2) {
        var mh$ = ntog6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntog6", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntos6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntos6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ntos6(graph *, int, int)
     * }
     */
    public static FunctionDescriptor ntos6$descriptor() {
        return ntos6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ntos6(graph *, int, int)
     * }
     */
    public static MethodHandle ntos6$handle() {
        return ntos6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ntos6(graph *, int, int)
     * }
     */
    public static MemorySegment ntos6$address() {
        return ntos6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ntos6(graph *, int, int)
     * }
     */
    public static MemorySegment ntos6(MemorySegment x0, int x1, int x2) {
        var mh$ = ntos6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntos6", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntod6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntod6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ntod6(graph *, int, int)
     * }
     */
    public static FunctionDescriptor ntod6$descriptor() {
        return ntod6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ntod6(graph *, int, int)
     * }
     */
    public static MethodHandle ntod6$handle() {
        return ntod6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ntod6(graph *, int, int)
     * }
     */
    public static MemorySegment ntod6$address() {
        return ntod6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ntod6(graph *, int, int)
     * }
     */
    public static MemorySegment ntod6(MemorySegment x0, int x1, int x2) {
        var mh$ = ntod6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntod6", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtos6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sgtos6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *sgtos6(sparsegraph *)
     * }
     */
    public static FunctionDescriptor sgtos6$descriptor() {
        return sgtos6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *sgtos6(sparsegraph *)
     * }
     */
    public static MethodHandle sgtos6$handle() {
        return sgtos6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *sgtos6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtos6$address() {
        return sgtos6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *sgtos6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtos6(MemorySegment x0) {
        var mh$ = sgtos6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtos6", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtog6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sgtog6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *sgtog6(sparsegraph *)
     * }
     */
    public static FunctionDescriptor sgtog6$descriptor() {
        return sgtog6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *sgtog6(sparsegraph *)
     * }
     */
    public static MethodHandle sgtog6$handle() {
        return sgtog6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *sgtog6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtog6$address() {
        return sgtog6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *sgtog6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtog6(MemorySegment x0) {
        var mh$ = sgtog6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtog6", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtod6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sgtod6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *sgtod6(sparsegraph *)
     * }
     */
    public static FunctionDescriptor sgtod6$descriptor() {
        return sgtod6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *sgtod6(sparsegraph *)
     * }
     */
    public static MethodHandle sgtod6$handle() {
        return sgtod6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *sgtod6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtod6$address() {
        return sgtod6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *sgtod6(sparsegraph *)
     * }
     */
    public static MemorySegment sgtod6(MemorySegment x0) {
        var mh$ = sgtod6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtod6", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeg6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeg6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeg6(FILE *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor writeg6$descriptor() {
        return writeg6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeg6(FILE *, graph *, int, int)
     * }
     */
    public static MethodHandle writeg6$handle() {
        return writeg6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeg6(FILE *, graph *, int, int)
     * }
     */
    public static MemorySegment writeg6$address() {
        return writeg6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeg6(FILE *, graph *, int, int)
     * }
     */
    public static void writeg6(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = writeg6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeg6", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writed6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writed6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writed6(FILE *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor writed6$descriptor() {
        return writed6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writed6(FILE *, graph *, int, int)
     * }
     */
    public static MethodHandle writed6$handle() {
        return writed6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writed6(FILE *, graph *, int, int)
     * }
     */
    public static MemorySegment writed6$address() {
        return writed6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writed6(FILE *, graph *, int, int)
     * }
     */
    public static void writed6(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = writed6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writed6", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writes6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writes6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writes6(FILE *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor writes6$descriptor() {
        return writes6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writes6(FILE *, graph *, int, int)
     * }
     */
    public static MethodHandle writes6$handle() {
        return writes6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writes6(FILE *, graph *, int, int)
     * }
     */
    public static MemorySegment writes6$address() {
        return writes6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writes6(FILE *, graph *, int, int)
     * }
     */
    public static void writes6(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = writes6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writes6", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeg6_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeg6_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeg6_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor writeg6_sg$descriptor() {
        return writeg6_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeg6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle writeg6_sg$handle() {
        return writeg6_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeg6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment writeg6_sg$address() {
        return writeg6_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeg6_sg(FILE *, sparsegraph *)
     * }
     */
    public static void writeg6_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = writeg6_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeg6_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writes6_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writes6_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writes6_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor writes6_sg$descriptor() {
        return writes6_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writes6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle writes6_sg$handle() {
        return writes6_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writes6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment writes6_sg$address() {
        return writes6_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writes6_sg(FILE *, sparsegraph *)
     * }
     */
    public static void writes6_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = writes6_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writes6_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writed6_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writed6_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writed6_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor writed6_sg$descriptor() {
        return writed6_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writed6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle writed6_sg$handle() {
        return writed6_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writed6_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment writed6_sg$address() {
        return writed6_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writed6_sg(FILE *, sparsegraph *)
     * }
     */
    public static void writed6_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = writed6_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writed6_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntois6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntois6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ntois6(graph *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor ntois6$descriptor() {
        return ntois6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ntois6(graph *, graph *, int, int)
     * }
     */
    public static MethodHandle ntois6$handle() {
        return ntois6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ntois6(graph *, graph *, int, int)
     * }
     */
    public static MemorySegment ntois6$address() {
        return ntois6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ntois6(graph *, graph *, int, int)
     * }
     */
    public static MemorySegment ntois6(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = ntois6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntois6", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writeis6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writeis6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writeis6(FILE *, graph *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor writeis6$descriptor() {
        return writeis6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writeis6(FILE *, graph *, graph *, int, int)
     * }
     */
    public static MethodHandle writeis6$handle() {
        return writeis6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writeis6(FILE *, graph *, graph *, int, int)
     * }
     */
    public static MemorySegment writeis6$address() {
        return writeis6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writeis6(FILE *, graph *, graph *, int, int)
     * }
     */
    public static void writeis6(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4) {
        var mh$ = writeis6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writeis6", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writepc_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writepc_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writepc_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor writepc_sg$descriptor() {
        return writepc_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writepc_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle writepc_sg$handle() {
        return writepc_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writepc_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment writepc_sg$address() {
        return writepc_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writepc_sg(FILE *, sparsegraph *)
     * }
     */
    public static void writepc_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = writepc_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writepc_sg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stringtosparsegraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stringtosparsegraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stringtosparsegraph(char *, sparsegraph *, int *)
     * }
     */
    public static FunctionDescriptor stringtosparsegraph$descriptor() {
        return stringtosparsegraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stringtosparsegraph(char *, sparsegraph *, int *)
     * }
     */
    public static MethodHandle stringtosparsegraph$handle() {
        return stringtosparsegraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stringtosparsegraph(char *, sparsegraph *, int *)
     * }
     */
    public static MemorySegment stringtosparsegraph$address() {
        return stringtosparsegraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stringtosparsegraph(char *, sparsegraph *, int *)
     * }
     */
    public static void stringtosparsegraph(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = stringtosparsegraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stringtosparsegraph", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("read_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *read_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor read_sg$descriptor() {
        return read_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *read_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle read_sg$handle() {
        return read_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *read_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment read_sg$address() {
        return read_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *read_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment read_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = read_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read_sg", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read_sg_loops {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("read_sg_loops");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *read_sg_loops(FILE *, sparsegraph *, int *)
     * }
     */
    public static FunctionDescriptor read_sg_loops$descriptor() {
        return read_sg_loops.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *read_sg_loops(FILE *, sparsegraph *, int *)
     * }
     */
    public static MethodHandle read_sg_loops$handle() {
        return read_sg_loops.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *read_sg_loops(FILE *, sparsegraph *, int *)
     * }
     */
    public static MemorySegment read_sg_loops$address() {
        return read_sg_loops.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *read_sg_loops(FILE *, sparsegraph *, int *)
     * }
     */
    public static MemorySegment read_sg_loops(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = read_sg_loops.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read_sg_loops", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read_sgg_loops {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("read_sgg_loops");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *read_sgg_loops(FILE *, sparsegraph *, int *, boolean *)
     * }
     */
    public static FunctionDescriptor read_sgg_loops$descriptor() {
        return read_sgg_loops.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *read_sgg_loops(FILE *, sparsegraph *, int *, boolean *)
     * }
     */
    public static MethodHandle read_sgg_loops$handle() {
        return read_sgg_loops.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *read_sgg_loops(FILE *, sparsegraph *, int *, boolean *)
     * }
     */
    public static MemorySegment read_sgg_loops$address() {
        return read_sgg_loops.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *read_sgg_loops(FILE *, sparsegraph *, int *, boolean *)
     * }
     */
    public static MemorySegment read_sgg_loops(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = read_sgg_loops.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read_sgg_loops", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readpc_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readpc_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *readpc_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor readpc_sg$descriptor() {
        return readpc_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *readpc_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle readpc_sg$handle() {
        return readpc_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *readpc_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment readpc_sg$address() {
        return readpc_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *readpc_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment readpc_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = readpc_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readpc_sg", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readpcle_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readpcle_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * sparsegraph *readpcle_sg(FILE *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor readpcle_sg$descriptor() {
        return readpcle_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * sparsegraph *readpcle_sg(FILE *, sparsegraph *)
     * }
     */
    public static MethodHandle readpcle_sg$handle() {
        return readpcle_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * sparsegraph *readpcle_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment readpcle_sg$address() {
        return readpcle_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * sparsegraph *readpcle_sg(FILE *, sparsegraph *)
     * }
     */
    public static MemorySegment readpcle_sg(MemorySegment x0, MemorySegment x1) {
        var mh$ = readpcle_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readpcle_sg", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getecline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getecline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getecline(FILE *)
     * }
     */
    public static FunctionDescriptor getecline$descriptor() {
        return getecline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getecline(FILE *)
     * }
     */
    public static MethodHandle getecline$handle() {
        return getecline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getecline(FILE *)
     * }
     */
    public static MemorySegment getecline$address() {
        return getecline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getecline(FILE *)
     * }
     */
    public static MemorySegment getecline(MemorySegment x0) {
        var mh$ = getecline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getecline", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writelast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writelast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writelast(FILE *)
     * }
     */
    public static FunctionDescriptor writelast$descriptor() {
        return writelast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writelast(FILE *)
     * }
     */
    public static MethodHandle writelast$handle() {
        return writelast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writelast(FILE *)
     * }
     */
    public static MemorySegment writelast$address() {
        return writelast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writelast(FILE *)
     * }
     */
    public static void writelast(MemorySegment x0) {
        var mh$ = writelast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writelast", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class longvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("longvalue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int longvalue(char **, long *)
     * }
     */
    public static FunctionDescriptor longvalue$descriptor() {
        return longvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int longvalue(char **, long *)
     * }
     */
    public static MethodHandle longvalue$handle() {
        return longvalue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int longvalue(char **, long *)
     * }
     */
    public static MemorySegment longvalue$address() {
        return longvalue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int longvalue(char **, long *)
     * }
     */
    public static int longvalue(MemorySegment x0, MemorySegment x1) {
        var mh$ = longvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("longvalue", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ullvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ullvalue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ullvalue(char **, unsigned long long *)
     * }
     */
    public static FunctionDescriptor ullvalue$descriptor() {
        return ullvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ullvalue(char **, unsigned long long *)
     * }
     */
    public static MethodHandle ullvalue$handle() {
        return ullvalue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ullvalue(char **, unsigned long long *)
     * }
     */
    public static MemorySegment ullvalue$address() {
        return ullvalue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ullvalue(char **, unsigned long long *)
     * }
     */
    public static int ullvalue(MemorySegment x0, MemorySegment x1) {
        var mh$ = ullvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ullvalue", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_int(char **, int *, char *)
     * }
     */
    public static FunctionDescriptor arg_int$descriptor() {
        return arg_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_int(char **, int *, char *)
     * }
     */
    public static MethodHandle arg_int$handle() {
        return arg_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_int(char **, int *, char *)
     * }
     */
    public static MemorySegment arg_int$address() {
        return arg_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_int(char **, int *, char *)
     * }
     */
    public static void arg_int(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = arg_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_int", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_long");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_long(char **, long *, char *)
     * }
     */
    public static FunctionDescriptor arg_long$descriptor() {
        return arg_long.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_long(char **, long *, char *)
     * }
     */
    public static MethodHandle arg_long$handle() {
        return arg_long.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_long(char **, long *, char *)
     * }
     */
    public static MemorySegment arg_long$address() {
        return arg_long.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_long(char **, long *, char *)
     * }
     */
    public static void arg_long(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = arg_long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_long", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_ull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_ull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_ull(char **, unsigned long long *, char *)
     * }
     */
    public static FunctionDescriptor arg_ull$descriptor() {
        return arg_ull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_ull(char **, unsigned long long *, char *)
     * }
     */
    public static MethodHandle arg_ull$handle() {
        return arg_ull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_ull(char **, unsigned long long *, char *)
     * }
     */
    public static MemorySegment arg_ull$address() {
        return arg_ull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_ull(char **, unsigned long long *, char *)
     * }
     */
    public static void arg_ull(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = arg_ull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_ull", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_range(char **, char *, long *, long *, char *)
     * }
     */
    public static FunctionDescriptor arg_range$descriptor() {
        return arg_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_range(char **, char *, long *, long *, char *)
     * }
     */
    public static MethodHandle arg_range$handle() {
        return arg_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_range(char **, char *, long *, long *, char *)
     * }
     */
    public static MemorySegment arg_range$address() {
        return arg_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_range(char **, char *, long *, long *, char *)
     * }
     */
    public static void arg_range(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = arg_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_range", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class doublevalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("doublevalue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int doublevalue(char **, double *)
     * }
     */
    public static FunctionDescriptor doublevalue$descriptor() {
        return doublevalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int doublevalue(char **, double *)
     * }
     */
    public static MethodHandle doublevalue$handle() {
        return doublevalue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int doublevalue(char **, double *)
     * }
     */
    public static MemorySegment doublevalue$address() {
        return doublevalue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int doublevalue(char **, double *)
     * }
     */
    public static int doublevalue(MemorySegment x0, MemorySegment x1) {
        var mh$ = doublevalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("doublevalue", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_double(char **, double *, char *)
     * }
     */
    public static FunctionDescriptor arg_double$descriptor() {
        return arg_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_double(char **, double *, char *)
     * }
     */
    public static MethodHandle arg_double$handle() {
        return arg_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_double(char **, double *, char *)
     * }
     */
    public static MemorySegment arg_double$address() {
        return arg_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_double(char **, double *, char *)
     * }
     */
    public static void arg_double(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = arg_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_double", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_doublerange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_doublerange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_doublerange(char **, char *, double *, double *, char *)
     * }
     */
    public static FunctionDescriptor arg_doublerange$descriptor() {
        return arg_doublerange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_doublerange(char **, char *, double *, double *, char *)
     * }
     */
    public static MethodHandle arg_doublerange$handle() {
        return arg_doublerange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_doublerange(char **, char *, double *, double *, char *)
     * }
     */
    public static MemorySegment arg_doublerange$address() {
        return arg_doublerange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_doublerange(char **, char *, double *, double *, char *)
     * }
     */
    public static void arg_doublerange(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = arg_doublerange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_doublerange", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_sequence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_sequence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_sequence(char **, char *, long *, int, int *, char *)
     * }
     */
    public static FunctionDescriptor arg_sequence$descriptor() {
        return arg_sequence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_sequence(char **, char *, long *, int, int *, char *)
     * }
     */
    public static MethodHandle arg_sequence$handle() {
        return arg_sequence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_sequence(char **, char *, long *, int, int *, char *)
     * }
     */
    public static MemorySegment arg_sequence$address() {
        return arg_sequence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_sequence(char **, char *, long *, int, int *, char *)
     * }
     */
    public static void arg_sequence(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = arg_sequence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_sequence", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arg_sequence_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arg_sequence_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arg_sequence_min(char **, char *, long *, int, int, int *, char *)
     * }
     */
    public static FunctionDescriptor arg_sequence_min$descriptor() {
        return arg_sequence_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arg_sequence_min(char **, char *, long *, int, int, int *, char *)
     * }
     */
    public static MethodHandle arg_sequence_min$handle() {
        return arg_sequence_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arg_sequence_min(char **, char *, long *, int, int, int *, char *)
     * }
     */
    public static MemorySegment arg_sequence_min$address() {
        return arg_sequence_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arg_sequence_min(char **, char *, long *, int, int, int *, char *)
     * }
     */
    public static void arg_sequence_min(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = arg_sequence_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arg_sequence_min", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writerange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_LONG,
            NautyTraces.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writerange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void writerange(FILE *, int, long, long)
     * }
     */
    public static FunctionDescriptor writerange$descriptor() {
        return writerange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void writerange(FILE *, int, long, long)
     * }
     */
    public static MethodHandle writerange$handle() {
        return writerange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void writerange(FILE *, int, long, long)
     * }
     */
    public static MemorySegment writerange$address() {
        return writerange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void writerange(FILE *, int, long, long)
     * }
     */
    public static void writerange(MemorySegment x0, int x1, long x2, long x3) {
        var mh$ = writerange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writerange", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gt_abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gt_abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gt_abort(const char *)
     * }
     */
    public static FunctionDescriptor gt_abort$descriptor() {
        return gt_abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gt_abort(const char *)
     * }
     */
    public static MethodHandle gt_abort$handle() {
        return gt_abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gt_abort(const char *)
     * }
     */
    public static MemorySegment gt_abort$address() {
        return gt_abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gt_abort(const char *)
     * }
     */
    public static void gt_abort(MemorySegment x0) {
        var mh$ = gt_abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gt_abort", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stringcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stringcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stringcopy(char *)
     * }
     */
    public static FunctionDescriptor stringcopy$descriptor() {
        return stringcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stringcopy(char *)
     * }
     */
    public static MethodHandle stringcopy$handle() {
        return stringcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stringcopy(char *)
     * }
     */
    public static MemorySegment stringcopy$address() {
        return stringcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stringcopy(char *)
     * }
     */
    public static MemorySegment stringcopy(MemorySegment x0) {
        var mh$ = stringcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stringcopy", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strhaschar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strhaschar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean strhaschar(char *, int)
     * }
     */
    public static FunctionDescriptor strhaschar$descriptor() {
        return strhaschar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean strhaschar(char *, int)
     * }
     */
    public static MethodHandle strhaschar$handle() {
        return strhaschar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean strhaschar(char *, int)
     * }
     */
    public static MemorySegment strhaschar$address() {
        return strhaschar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean strhaschar(char *, int)
     * }
     */
    public static int strhaschar(MemorySegment x0, int x1) {
        var mh$ = strhaschar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strhaschar", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcanonise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcanonise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fcanonise(graph *, int, int, graph *, char *, boolean)
     * }
     */
    public static FunctionDescriptor fcanonise$descriptor() {
        return fcanonise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fcanonise(graph *, int, int, graph *, char *, boolean)
     * }
     */
    public static MethodHandle fcanonise$handle() {
        return fcanonise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fcanonise(graph *, int, int, graph *, char *, boolean)
     * }
     */
    public static MemorySegment fcanonise$address() {
        return fcanonise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fcanonise(graph *, int, int, graph *, char *, boolean)
     * }
     */
    public static void fcanonise(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, int x5) {
        var mh$ = fcanonise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcanonise", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcanonise_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcanonise_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fcanonise_inv(graph *, int, int, graph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static FunctionDescriptor fcanonise_inv$descriptor() {
        return fcanonise_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fcanonise_inv(graph *, int, int, graph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static MethodHandle fcanonise_inv$handle() {
        return fcanonise_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fcanonise_inv(graph *, int, int, graph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static MemorySegment fcanonise_inv$address() {
        return fcanonise_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fcanonise_inv(graph *, int, int, graph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static void fcanonise_inv(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7, int x8, int x9) {
        var mh$ = fcanonise_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcanonise_inv", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcanonise_inv_sg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcanonise_inv_sg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fcanonise_inv_sg(sparsegraph *, int, int, sparsegraph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static FunctionDescriptor fcanonise_inv_sg$descriptor() {
        return fcanonise_inv_sg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fcanonise_inv_sg(sparsegraph *, int, int, sparsegraph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static MethodHandle fcanonise_inv_sg$handle() {
        return fcanonise_inv_sg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fcanonise_inv_sg(sparsegraph *, int, int, sparsegraph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static MemorySegment fcanonise_inv_sg$address() {
        return fcanonise_inv_sg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fcanonise_inv_sg(sparsegraph *, int, int, sparsegraph *, char *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int, boolean)
     * }
     */
    public static void fcanonise_inv_sg(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, int x7, int x8, int x9) {
        var mh$ = fcanonise_inv_sg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcanonise_inv_sg", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlabptn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlabptn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setlabptn(int *, int *, int *, int)
     * }
     */
    public static FunctionDescriptor setlabptn$descriptor() {
        return setlabptn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setlabptn(int *, int *, int *, int)
     * }
     */
    public static MethodHandle setlabptn$handle() {
        return setlabptn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setlabptn(int *, int *, int *, int)
     * }
     */
    public static MemorySegment setlabptn$address() {
        return setlabptn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setlabptn(int *, int *, int *, int)
     * }
     */
    public static void setlabptn(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = setlabptn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlabptn", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class breakcellwt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("breakcellwt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int breakcellwt(int *, int *, int *, int, int)
     * }
     */
    public static FunctionDescriptor breakcellwt$descriptor() {
        return breakcellwt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int breakcellwt(int *, int *, int *, int, int)
     * }
     */
    public static MethodHandle breakcellwt$handle() {
        return breakcellwt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int breakcellwt(int *, int *, int *, int, int)
     * }
     */
    public static MemorySegment breakcellwt$address() {
        return breakcellwt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int breakcellwt(int *, int *, int *, int, int)
     * }
     */
    public static int breakcellwt(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4) {
        var mh$ = breakcellwt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("breakcellwt", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlabptnfmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlabptnfmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlabptnfmt(char *, int *, int *, set *, int, int)
     * }
     */
    public static FunctionDescriptor setlabptnfmt$descriptor() {
        return setlabptnfmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlabptnfmt(char *, int *, int *, set *, int, int)
     * }
     */
    public static MethodHandle setlabptnfmt$handle() {
        return setlabptnfmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlabptnfmt(char *, int *, int *, set *, int, int)
     * }
     */
    public static MemorySegment setlabptnfmt$address() {
        return setlabptnfmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlabptnfmt(char *, int *, int *, set *, int, int)
     * }
     */
    public static int setlabptnfmt(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, int x4, int x5) {
        var mh$ = setlabptnfmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlabptnfmt", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fgroup(graph *, int, int, char *, int *, int *)
     * }
     */
    public static FunctionDescriptor fgroup$descriptor() {
        return fgroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fgroup(graph *, int, int, char *, int *, int *)
     * }
     */
    public static MethodHandle fgroup$handle() {
        return fgroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fgroup(graph *, int, int, char *, int *, int *)
     * }
     */
    public static MemorySegment fgroup$address() {
        return fgroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fgroup(graph *, int, int, char *, int *, int *)
     * }
     */
    public static void fgroup(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = fgroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgroup", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgroup_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgroup_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void fgroup_inv(graph *, int, int, char *, int *, int *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int)
     * }
     */
    public static FunctionDescriptor fgroup_inv$descriptor() {
        return fgroup_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void fgroup_inv(graph *, int, int, char *, int *, int *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int)
     * }
     */
    public static MethodHandle fgroup_inv$handle() {
        return fgroup_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void fgroup_inv(graph *, int, int, char *, int *, int *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int)
     * }
     */
    public static MemorySegment fgroup_inv$address() {
        return fgroup_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void fgroup_inv(graph *, int, int, char *, int *, int *, void (*)(graph *, int *, int *, int, int, int, int *, int, boolean, int, int), int, int, int)
     * }
     */
    public static void fgroup_inv(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7, int x8, int x9) {
        var mh$ = fgroup_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgroup_inv", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class istransitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("istransitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int istransitive(graph *, int, int, graph *)
     * }
     */
    public static FunctionDescriptor istransitive$descriptor() {
        return istransitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int istransitive(graph *, int, int, graph *)
     * }
     */
    public static MethodHandle istransitive$handle() {
        return istransitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int istransitive(graph *, int, int, graph *)
     * }
     */
    public static MemorySegment istransitive$address() {
        return istransitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int istransitive(graph *, int, int, graph *)
     * }
     */
    public static int istransitive(MemorySegment x0, int x1, int x2, MemorySegment x3) {
        var mh$ = istransitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("istransitive", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tg_canonise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tg_canonise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tg_canonise(graph *, graph *, int, int)
     * }
     */
    public static FunctionDescriptor tg_canonise$descriptor() {
        return tg_canonise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tg_canonise(graph *, graph *, int, int)
     * }
     */
    public static MethodHandle tg_canonise$handle() {
        return tg_canonise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tg_canonise(graph *, graph *, int, int)
     * }
     */
    public static MemorySegment tg_canonise$address() {
        return tg_canonise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tg_canonise(graph *, graph *, int, int)
     * }
     */
    public static void tg_canonise(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = tg_canonise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tg_canonise", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class countorbits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("countorbits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void countorbits(graph *, int, int, boolean, double *, int *, int *, int *, size_t *, size_t *)
     * }
     */
    public static FunctionDescriptor countorbits$descriptor() {
        return countorbits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void countorbits(graph *, int, int, boolean, double *, int *, int *, int *, size_t *, size_t *)
     * }
     */
    public static MethodHandle countorbits$handle() {
        return countorbits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void countorbits(graph *, int, int, boolean, double *, int *, int *, int *, size_t *, size_t *)
     * }
     */
    public static MemorySegment countorbits$address() {
        return countorbits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void countorbits(graph *, int, int, boolean, double *, int *, int *, int *, size_t *, size_t *)
     * }
     */
    public static void countorbits(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = countorbits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("countorbits", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readg_code$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("readg_code").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Thread_local int readg_code
     * }
     */
    public static OfInt readg_code$layout() {
        return readg_code$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _Thread_local int readg_code
     * }
     */
    public static MemorySegment readg_code$segment() {
        return readg_code$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Thread_local int readg_code
     * }
     */
    public static int readg_code() {
        return readg_code$constants.SEGMENT.get(readg_code$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Thread_local int readg_code
     * }
     */
    public static void readg_code(int varValue) {
        readg_code$constants.SEGMENT.set(readg_code$constants.LAYOUT, 0L, varValue);
    }

    private static class readg_line$constants {
        public static final AddressLayout LAYOUT = NautyTraces.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("readg_line").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Thread_local char *readg_line
     * }
     */
    public static AddressLayout readg_line$layout() {
        return readg_line$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _Thread_local char *readg_line
     * }
     */
    public static MemorySegment readg_line$segment() {
        return readg_line$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Thread_local char *readg_line
     * }
     */
    public static MemorySegment readg_line() {
        return readg_line$constants.SEGMENT.get(readg_line$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Thread_local char *readg_line
     * }
     */
    public static void readg_line(MemorySegment varValue) {
        readg_line$constants.SEGMENT.set(readg_line$constants.LAYOUT, 0L, varValue);
    }

    private static class ogf_linelen$constants {
        public static final OfLong LAYOUT = NautyTraces.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("ogf_linelen").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Thread_local size_t ogf_linelen
     * }
     */
    public static OfLong ogf_linelen$layout() {
        return ogf_linelen$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _Thread_local size_t ogf_linelen
     * }
     */
    public static MemorySegment ogf_linelen$segment() {
        return ogf_linelen$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Thread_local size_t ogf_linelen
     * }
     */
    public static long ogf_linelen() {
        return ogf_linelen$constants.SEGMENT.get(ogf_linelen$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Thread_local size_t ogf_linelen
     * }
     */
    public static void ogf_linelen(long varValue) {
        ogf_linelen$constants.SEGMENT.set(ogf_linelen$constants.LAYOUT, 0L, varValue);
    }

    private static class is_pipe$constants {
        public static final OfInt LAYOUT = NautyTraces.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("is_pipe").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Thread_local boolean is_pipe
     * }
     */
    public static OfInt is_pipe$layout() {
        return is_pipe$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _Thread_local boolean is_pipe
     * }
     */
    public static MemorySegment is_pipe$segment() {
        return is_pipe$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Thread_local boolean is_pipe
     * }
     */
    public static int is_pipe() {
        return is_pipe$constants.SEGMENT.get(is_pipe$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Thread_local boolean is_pipe
     * }
     */
    public static void is_pipe(int varValue) {
        is_pipe$constants.SEGMENT.set(is_pipe$constants.LAYOUT, 0L, varValue);
    }

    private static class freeschreier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freeschreier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void freeschreier(schreier **gp, permnode **gens)
     * }
     */
    public static FunctionDescriptor freeschreier$descriptor() {
        return freeschreier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void freeschreier(schreier **gp, permnode **gens)
     * }
     */
    public static MethodHandle freeschreier$handle() {
        return freeschreier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void freeschreier(schreier **gp, permnode **gens)
     * }
     */
    public static MemorySegment freeschreier$address() {
        return freeschreier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void freeschreier(schreier **gp, permnode **gens)
     * }
     */
    public static void freeschreier(MemorySegment gp, MemorySegment gens) {
        var mh$ = freeschreier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freeschreier", gp, gens);
            }
            mh$.invokeExact(gp, gens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class addpermutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("addpermutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void addpermutation(permnode **ring, int *p, int n)
     * }
     */
    public static FunctionDescriptor addpermutation$descriptor() {
        return addpermutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void addpermutation(permnode **ring, int *p, int n)
     * }
     */
    public static MethodHandle addpermutation$handle() {
        return addpermutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void addpermutation(permnode **ring, int *p, int n)
     * }
     */
    public static MemorySegment addpermutation$address() {
        return addpermutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void addpermutation(permnode **ring, int *p, int n)
     * }
     */
    public static void addpermutation(MemorySegment ring, MemorySegment p, int n) {
        var mh$ = addpermutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("addpermutation", ring, p, n);
            }
            mh$.invokeExact(ring, p, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class findpermutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("findpermutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * permnode *findpermutation(permnode *gens, int *p, int n)
     * }
     */
    public static FunctionDescriptor findpermutation$descriptor() {
        return findpermutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * permnode *findpermutation(permnode *gens, int *p, int n)
     * }
     */
    public static MethodHandle findpermutation$handle() {
        return findpermutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * permnode *findpermutation(permnode *gens, int *p, int n)
     * }
     */
    public static MemorySegment findpermutation$address() {
        return findpermutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * permnode *findpermutation(permnode *gens, int *p, int n)
     * }
     */
    public static MemorySegment findpermutation(MemorySegment gens, MemorySegment p, int n) {
        var mh$ = findpermutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("findpermutation", gens, p, n);
            }
            return (MemorySegment)mh$.invokeExact(gens, p, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class addgenerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("addgenerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean addgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static FunctionDescriptor addgenerator$descriptor() {
        return addgenerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean addgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static MethodHandle addgenerator$handle() {
        return addgenerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean addgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static MemorySegment addgenerator$address() {
        return addgenerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean addgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static int addgenerator(MemorySegment gp, MemorySegment gens, MemorySegment p, int n) {
        var mh$ = addgenerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("addgenerator", gp, gens, p, n);
            }
            return (int)mh$.invokeExact(gp, gens, p, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class condaddgenerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("condaddgenerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean condaddgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static FunctionDescriptor condaddgenerator$descriptor() {
        return condaddgenerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean condaddgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static MethodHandle condaddgenerator$handle() {
        return condaddgenerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean condaddgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static MemorySegment condaddgenerator$address() {
        return condaddgenerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean condaddgenerator(schreier **gp, permnode **gens, int *p, int n)
     * }
     */
    public static int condaddgenerator(MemorySegment gp, MemorySegment gens, MemorySegment p, int n) {
        var mh$ = condaddgenerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("condaddgenerator", gp, gens, p, n);
            }
            return (int)mh$.invokeExact(gp, gens, p, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expandschreier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expandschreier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * boolean expandschreier(schreier *gp, permnode **gens, int n)
     * }
     */
    public static FunctionDescriptor expandschreier$descriptor() {
        return expandschreier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * boolean expandschreier(schreier *gp, permnode **gens, int n)
     * }
     */
    public static MethodHandle expandschreier$handle() {
        return expandschreier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * boolean expandschreier(schreier *gp, permnode **gens, int n)
     * }
     */
    public static MemorySegment expandschreier$address() {
        return expandschreier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * boolean expandschreier(schreier *gp, permnode **gens, int n)
     * }
     */
    public static int expandschreier(MemorySegment gp, MemorySegment gens, int n) {
        var mh$ = expandschreier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expandschreier", gp, gens, n);
            }
            return (int)mh$.invokeExact(gp, gens, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getorbits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getorbits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *getorbits(int *fix, int nfix, schreier *gp, permnode **gens, int n)
     * }
     */
    public static FunctionDescriptor getorbits$descriptor() {
        return getorbits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *getorbits(int *fix, int nfix, schreier *gp, permnode **gens, int n)
     * }
     */
    public static MethodHandle getorbits$handle() {
        return getorbits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *getorbits(int *fix, int nfix, schreier *gp, permnode **gens, int n)
     * }
     */
    public static MemorySegment getorbits$address() {
        return getorbits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *getorbits(int *fix, int nfix, schreier *gp, permnode **gens, int n)
     * }
     */
    public static MemorySegment getorbits(MemorySegment fix, int nfix, MemorySegment gp, MemorySegment gens, int n) {
        var mh$ = getorbits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getorbits", fix, nfix, gp, gens, n);
            }
            return (MemorySegment)mh$.invokeExact(fix, nfix, gp, gens, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getorbitsmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getorbitsmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getorbitsmin(int *fix, int nfix, schreier *gp, permnode **gens, int **orbits, int *cell, int ncell, int n, boolean changed)
     * }
     */
    public static FunctionDescriptor getorbitsmin$descriptor() {
        return getorbitsmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getorbitsmin(int *fix, int nfix, schreier *gp, permnode **gens, int **orbits, int *cell, int ncell, int n, boolean changed)
     * }
     */
    public static MethodHandle getorbitsmin$handle() {
        return getorbitsmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getorbitsmin(int *fix, int nfix, schreier *gp, permnode **gens, int **orbits, int *cell, int ncell, int n, boolean changed)
     * }
     */
    public static MemorySegment getorbitsmin$address() {
        return getorbitsmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getorbitsmin(int *fix, int nfix, schreier *gp, permnode **gens, int **orbits, int *cell, int ncell, int n, boolean changed)
     * }
     */
    public static int getorbitsmin(MemorySegment fix, int nfix, MemorySegment gp, MemorySegment gens, MemorySegment orbits, MemorySegment cell, int ncell, int n, int changed) {
        var mh$ = getorbitsmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getorbitsmin", fix, nfix, gp, gens, orbits, cell, ncell, n, changed);
            }
            return (int)mh$.invokeExact(fix, nfix, gp, gens, orbits, cell, ncell, n, changed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pruneset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pruneset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pruneset(set *fixset, schreier *gp, permnode **gens, set *x, int m, int n)
     * }
     */
    public static FunctionDescriptor pruneset$descriptor() {
        return pruneset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pruneset(set *fixset, schreier *gp, permnode **gens, set *x, int m, int n)
     * }
     */
    public static MethodHandle pruneset$handle() {
        return pruneset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pruneset(set *fixset, schreier *gp, permnode **gens, set *x, int m, int n)
     * }
     */
    public static MemorySegment pruneset$address() {
        return pruneset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pruneset(set *fixset, schreier *gp, permnode **gens, set *x, int m, int n)
     * }
     */
    public static void pruneset(MemorySegment fixset, MemorySegment gp, MemorySegment gens, MemorySegment x, int m, int n) {
        var mh$ = pruneset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pruneset", fixset, gp, gens, x, m, n);
            }
            mh$.invokeExact(fixset, gp, gens, x, m, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class newgroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("newgroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void newgroup(schreier **gp, permnode **gens, int n)
     * }
     */
    public static FunctionDescriptor newgroup$descriptor() {
        return newgroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void newgroup(schreier **gp, permnode **gens, int n)
     * }
     */
    public static MethodHandle newgroup$handle() {
        return newgroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void newgroup(schreier **gp, permnode **gens, int n)
     * }
     */
    public static MemorySegment newgroup$address() {
        return newgroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void newgroup(schreier **gp, permnode **gens, int n)
     * }
     */
    public static void newgroup(MemorySegment gp, MemorySegment gens, int n) {
        var mh$ = newgroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("newgroup", gp, gens, n);
            }
            mh$.invokeExact(gp, gens, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class schreier_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("schreier_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void schreier_freedyn()
     * }
     */
    public static FunctionDescriptor schreier_freedyn$descriptor() {
        return schreier_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void schreier_freedyn()
     * }
     */
    public static MethodHandle schreier_freedyn$handle() {
        return schreier_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void schreier_freedyn()
     * }
     */
    public static MemorySegment schreier_freedyn$address() {
        return schreier_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void schreier_freedyn()
     * }
     */
    public static void schreier_freedyn() {
        var mh$ = schreier_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("schreier_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class schreier_fails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("schreier_fails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int schreier_fails(int nfails)
     * }
     */
    public static FunctionDescriptor schreier_fails$descriptor() {
        return schreier_fails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int schreier_fails(int nfails)
     * }
     */
    public static MethodHandle schreier_fails$handle() {
        return schreier_fails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int schreier_fails(int nfails)
     * }
     */
    public static MemorySegment schreier_fails$address() {
        return schreier_fails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int schreier_fails(int nfails)
     * }
     */
    public static int schreier_fails(int nfails) {
        var mh$ = schreier_fails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("schreier_fails", nfails);
            }
            return (int)mh$.invokeExact(nfails);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dumpschreier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dumpschreier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dumpschreier(FILE *f, schreier *gp, permnode *gens, int n)
     * }
     */
    public static FunctionDescriptor dumpschreier$descriptor() {
        return dumpschreier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dumpschreier(FILE *f, schreier *gp, permnode *gens, int n)
     * }
     */
    public static MethodHandle dumpschreier$handle() {
        return dumpschreier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dumpschreier(FILE *f, schreier *gp, permnode *gens, int n)
     * }
     */
    public static MemorySegment dumpschreier$address() {
        return dumpschreier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dumpschreier(FILE *f, schreier *gp, permnode *gens, int n)
     * }
     */
    public static void dumpschreier(MemorySegment f, MemorySegment gp, MemorySegment gens, int n) {
        var mh$ = dumpschreier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dumpschreier", f, gp, gens, n);
            }
            mh$.invokeExact(f, gp, gens, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class schreier_gens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            NautyTraces.C_INT,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("schreier_gens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int schreier_gens(permnode *gens)
     * }
     */
    public static FunctionDescriptor schreier_gens$descriptor() {
        return schreier_gens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int schreier_gens(permnode *gens)
     * }
     */
    public static MethodHandle schreier_gens$handle() {
        return schreier_gens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int schreier_gens(permnode *gens)
     * }
     */
    public static MemorySegment schreier_gens$address() {
        return schreier_gens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int schreier_gens(permnode *gens)
     * }
     */
    public static int schreier_gens(MemorySegment gens) {
        var mh$ = schreier_gens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("schreier_gens", gens);
            }
            return (int)mh$.invokeExact(gens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class deleteunmarked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("deleteunmarked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void deleteunmarked(permnode **gens)
     * }
     */
    public static FunctionDescriptor deleteunmarked$descriptor() {
        return deleteunmarked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void deleteunmarked(permnode **gens)
     * }
     */
    public static MethodHandle deleteunmarked$handle() {
        return deleteunmarked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void deleteunmarked(permnode **gens)
     * }
     */
    public static MemorySegment deleteunmarked$address() {
        return deleteunmarked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void deleteunmarked(permnode **gens)
     * }
     */
    public static void deleteunmarked(MemorySegment gens) {
        var mh$ = deleteunmarked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("deleteunmarked", gens);
            }
            mh$.invokeExact(gens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grouporder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_INT,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("grouporder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void grouporder(int *fix, int nfix, schreier *gp, permnode **gens, double *grpsize1, int *grpsize2, int n)
     * }
     */
    public static FunctionDescriptor grouporder$descriptor() {
        return grouporder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void grouporder(int *fix, int nfix, schreier *gp, permnode **gens, double *grpsize1, int *grpsize2, int n)
     * }
     */
    public static MethodHandle grouporder$handle() {
        return grouporder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void grouporder(int *fix, int nfix, schreier *gp, permnode **gens, double *grpsize1, int *grpsize2, int n)
     * }
     */
    public static MemorySegment grouporder$address() {
        return grouporder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void grouporder(int *fix, int nfix, schreier *gp, permnode **gens, double *grpsize1, int *grpsize2, int n)
     * }
     */
    public static void grouporder(MemorySegment fix, int nfix, MemorySegment gp, MemorySegment gens, MemorySegment grpsize1, MemorySegment grpsize2, int n) {
        var mh$ = grouporder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grouporder", fix, nfix, gp, gens, grpsize1, grpsize2, n);
            }
            mh$.invokeExact(fix, nfix, gp, gens, grpsize1, grpsize2, n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class schreier_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT,
            NautyTraces.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("schreier_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void schreier_check(int wordsize, int m, int n, int version)
     * }
     */
    public static FunctionDescriptor schreier_check$descriptor() {
        return schreier_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void schreier_check(int wordsize, int m, int n, int version)
     * }
     */
    public static MethodHandle schreier_check$handle() {
        return schreier_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void schreier_check(int wordsize, int m, int n, int version)
     * }
     */
    public static MemorySegment schreier_check$address() {
        return schreier_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void schreier_check(int wordsize, int m, int n, int version)
     * }
     */
    public static void schreier_check(int wordsize, int m, int n, int version) {
        var mh$ = schreier_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("schreier_check", wordsize, m, n, version);
            }
            mh$.invokeExact(wordsize, m, n, version);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Traces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("Traces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Traces(sparsegraph *, int *, int *, int *, TracesOptions *, TracesStats *, sparsegraph *)
     * }
     */
    public static FunctionDescriptor Traces$descriptor() {
        return Traces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Traces(sparsegraph *, int *, int *, int *, TracesOptions *, TracesStats *, sparsegraph *)
     * }
     */
    public static MethodHandle Traces$handle() {
        return Traces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Traces(sparsegraph *, int *, int *, int *, TracesOptions *, TracesStats *, sparsegraph *)
     * }
     */
    public static MemorySegment Traces$address() {
        return Traces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Traces(sparsegraph *, int *, int *, int *, TracesOptions *, TracesStats *, sparsegraph *)
     * }
     */
    public static void Traces(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Traces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Traces", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class refine_tr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER,
            NautyTraces.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("refine_tr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void refine_tr(sparsegraph *, int *, int *, int *, int *, TracesOptions *)
     * }
     */
    public static FunctionDescriptor refine_tr$descriptor() {
        return refine_tr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void refine_tr(sparsegraph *, int *, int *, int *, int *, TracesOptions *)
     * }
     */
    public static MethodHandle refine_tr$handle() {
        return refine_tr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void refine_tr(sparsegraph *, int *, int *, int *, int *, TracesOptions *)
     * }
     */
    public static MemorySegment refine_tr$address() {
        return refine_tr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void refine_tr(sparsegraph *, int *, int *, int *, int *, TracesOptions *)
     * }
     */
    public static void refine_tr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = refine_tr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("refine_tr", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class traces_freedyn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("traces_freedyn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void traces_freedyn()
     * }
     */
    public static FunctionDescriptor traces_freedyn$descriptor() {
        return traces_freedyn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void traces_freedyn()
     * }
     */
    public static MethodHandle traces_freedyn$handle() {
        return traces_freedyn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void traces_freedyn()
     * }
     */
    public static MemorySegment traces_freedyn$address() {
        return traces_freedyn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void traces_freedyn()
     * }
     */
    public static void traces_freedyn() {
        var mh$ = traces_freedyn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("traces_freedyn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = NautyTraces.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final long _POSIX_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VERSION 200809
     * }
     */
    public static long _POSIX_VERSION() {
        return _POSIX_VERSION;
    }
    private static final long __POSIX2_THIS_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define __POSIX2_THIS_VERSION 200809
     * }
     */
    public static long __POSIX2_THIS_VERSION() {
        return __POSIX2_THIS_VERSION;
    }
    private static final long _POSIX2_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_VERSION 200809
     * }
     */
    public static long _POSIX2_VERSION() {
        return _POSIX2_VERSION;
    }
    private static final long _POSIX2_C_VERSION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_VERSION 200809
     * }
     */
    public static long _POSIX2_C_VERSION() {
        return _POSIX2_C_VERSION;
    }
    private static final long _POSIX2_C_BIND = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_BIND 200809
     * }
     */
    public static long _POSIX2_C_BIND() {
        return _POSIX2_C_BIND;
    }
    private static final long _POSIX2_C_DEV = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_DEV 200809
     * }
     */
    public static long _POSIX2_C_DEV() {
        return _POSIX2_C_DEV;
    }
    private static final long _POSIX2_SW_DEV = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_SW_DEV 200809
     * }
     */
    public static long _POSIX2_SW_DEV() {
        return _POSIX2_SW_DEV;
    }
    private static final long _POSIX2_LOCALEDEF = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LOCALEDEF 200809
     * }
     */
    public static long _POSIX2_LOCALEDEF() {
        return _POSIX2_LOCALEDEF;
    }
    private static final long _POSIX_PRIORITY_SCHEDULING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITY_SCHEDULING 200809
     * }
     */
    public static long _POSIX_PRIORITY_SCHEDULING() {
        return _POSIX_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_SYNCHRONIZED_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYNCHRONIZED_IO 200809
     * }
     */
    public static long _POSIX_SYNCHRONIZED_IO() {
        return _POSIX_SYNCHRONIZED_IO;
    }
    private static final long _POSIX_FSYNC = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_FSYNC 200809
     * }
     */
    public static long _POSIX_FSYNC() {
        return _POSIX_FSYNC;
    }
    private static final long _POSIX_MAPPED_FILES = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAPPED_FILES 200809
     * }
     */
    public static long _POSIX_MAPPED_FILES() {
        return _POSIX_MAPPED_FILES;
    }
    private static final long _POSIX_MEMLOCK = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK 200809
     * }
     */
    public static long _POSIX_MEMLOCK() {
        return _POSIX_MEMLOCK;
    }
    private static final long _POSIX_MEMLOCK_RANGE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK_RANGE 200809
     * }
     */
    public static long _POSIX_MEMLOCK_RANGE() {
        return _POSIX_MEMLOCK_RANGE;
    }
    private static final long _POSIX_MEMORY_PROTECTION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMORY_PROTECTION 200809
     * }
     */
    public static long _POSIX_MEMORY_PROTECTION() {
        return _POSIX_MEMORY_PROTECTION;
    }
    private static final int _POSIX_VDISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VDISABLE 0
     * }
     */
    public static int _POSIX_VDISABLE() {
        return _POSIX_VDISABLE;
    }
    private static final long _POSIX_THREADS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREADS 200809
     * }
     */
    public static long _POSIX_THREADS() {
        return _POSIX_THREADS;
    }
    private static final long _POSIX_THREAD_SAFE_FUNCTIONS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SAFE_FUNCTIONS 200809
     * }
     */
    public static long _POSIX_THREAD_SAFE_FUNCTIONS() {
        return _POSIX_THREAD_SAFE_FUNCTIONS;
    }
    private static final long _POSIX_THREAD_PRIORITY_SCHEDULING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIORITY_SCHEDULING 200809
     * }
     */
    public static long _POSIX_THREAD_PRIORITY_SCHEDULING() {
        return _POSIX_THREAD_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_THREAD_ATTR_STACKSIZE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKSIZE 200809
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKSIZE() {
        return _POSIX_THREAD_ATTR_STACKSIZE;
    }
    private static final long _POSIX_THREAD_ATTR_STACKADDR = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKADDR 200809
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKADDR() {
        return _POSIX_THREAD_ATTR_STACKADDR;
    }
    private static final long _POSIX_THREAD_PRIO_INHERIT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_INHERIT 200809
     * }
     */
    public static long _POSIX_THREAD_PRIO_INHERIT() {
        return _POSIX_THREAD_PRIO_INHERIT;
    }
    private static final long _POSIX_THREAD_PRIO_PROTECT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_PROTECT 200809
     * }
     */
    public static long _POSIX_THREAD_PRIO_PROTECT() {
        return _POSIX_THREAD_PRIO_PROTECT;
    }
    private static final long _POSIX_THREAD_ROBUST_PRIO_INHERIT = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ROBUST_PRIO_INHERIT 200809
     * }
     */
    public static long _POSIX_THREAD_ROBUST_PRIO_INHERIT() {
        return _POSIX_THREAD_ROBUST_PRIO_INHERIT;
    }
    private static final int _POSIX_THREAD_ROBUST_PRIO_PROTECT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ROBUST_PRIO_PROTECT -1
     * }
     */
    public static int _POSIX_THREAD_ROBUST_PRIO_PROTECT() {
        return _POSIX_THREAD_ROBUST_PRIO_PROTECT;
    }
    private static final long _POSIX_SEMAPHORES = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEMAPHORES 200809
     * }
     */
    public static long _POSIX_SEMAPHORES() {
        return _POSIX_SEMAPHORES;
    }
    private static final long _POSIX_REALTIME_SIGNALS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REALTIME_SIGNALS 200809
     * }
     */
    public static long _POSIX_REALTIME_SIGNALS() {
        return _POSIX_REALTIME_SIGNALS;
    }
    private static final long _POSIX_ASYNCHRONOUS_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ASYNCHRONOUS_IO 200809
     * }
     */
    public static long _POSIX_ASYNCHRONOUS_IO() {
        return _POSIX_ASYNCHRONOUS_IO;
    }
    private static final long _POSIX_PRIORITIZED_IO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITIZED_IO 200809
     * }
     */
    public static long _POSIX_PRIORITIZED_IO() {
        return _POSIX_PRIORITIZED_IO;
    }
    private static final long _POSIX_SHARED_MEMORY_OBJECTS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHARED_MEMORY_OBJECTS 200809
     * }
     */
    public static long _POSIX_SHARED_MEMORY_OBJECTS() {
        return _POSIX_SHARED_MEMORY_OBJECTS;
    }
    private static final long _POSIX_READER_WRITER_LOCKS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_READER_WRITER_LOCKS 200809
     * }
     */
    public static long _POSIX_READER_WRITER_LOCKS() {
        return _POSIX_READER_WRITER_LOCKS;
    }
    private static final long _POSIX_TIMEOUTS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMEOUTS 200809
     * }
     */
    public static long _POSIX_TIMEOUTS() {
        return _POSIX_TIMEOUTS;
    }
    private static final long _POSIX_SPIN_LOCKS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPIN_LOCKS 200809
     * }
     */
    public static long _POSIX_SPIN_LOCKS() {
        return _POSIX_SPIN_LOCKS;
    }
    private static final long _POSIX_SPAWN = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPAWN 200809
     * }
     */
    public static long _POSIX_SPAWN() {
        return _POSIX_SPAWN;
    }
    private static final long _POSIX_TIMERS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMERS 200809
     * }
     */
    public static long _POSIX_TIMERS() {
        return _POSIX_TIMERS;
    }
    private static final long _POSIX_BARRIERS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_BARRIERS 200809
     * }
     */
    public static long _POSIX_BARRIERS() {
        return _POSIX_BARRIERS;
    }
    private static final long _POSIX_MESSAGE_PASSING = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MESSAGE_PASSING 200809
     * }
     */
    public static long _POSIX_MESSAGE_PASSING() {
        return _POSIX_MESSAGE_PASSING;
    }
    private static final long _POSIX_THREAD_PROCESS_SHARED = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PROCESS_SHARED 200809
     * }
     */
    public static long _POSIX_THREAD_PROCESS_SHARED() {
        return _POSIX_THREAD_PROCESS_SHARED;
    }
    private static final long _POSIX_CLOCK_SELECTION = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCK_SELECTION 200809
     * }
     */
    public static long _POSIX_CLOCK_SELECTION() {
        return _POSIX_CLOCK_SELECTION;
    }
    private static final long _POSIX_ADVISORY_INFO = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ADVISORY_INFO 200809
     * }
     */
    public static long _POSIX_ADVISORY_INFO() {
        return _POSIX_ADVISORY_INFO;
    }
    private static final long _POSIX_IPV6 = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_IPV6 200809
     * }
     */
    public static long _POSIX_IPV6() {
        return _POSIX_IPV6;
    }
    private static final long _POSIX_RAW_SOCKETS = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RAW_SOCKETS 200809
     * }
     */
    public static long _POSIX_RAW_SOCKETS() {
        return _POSIX_RAW_SOCKETS;
    }
    private static final long _POSIX2_CHAR_TERM = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHAR_TERM 200809
     * }
     */
    public static long _POSIX2_CHAR_TERM() {
        return _POSIX2_CHAR_TERM;
    }
    private static final int _POSIX_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_SPORADIC_SERVER() {
        return _POSIX_SPORADIC_SERVER;
    }
    private static final int _POSIX_THREAD_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_THREAD_SPORADIC_SERVER() {
        return _POSIX_THREAD_SPORADIC_SERVER;
    }
    private static final int _POSIX_TRACE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE -1
     * }
     */
    public static int _POSIX_TRACE() {
        return _POSIX_TRACE;
    }
    private static final int _POSIX_TRACE_EVENT_FILTER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_EVENT_FILTER -1
     * }
     */
    public static int _POSIX_TRACE_EVENT_FILTER() {
        return _POSIX_TRACE_EVENT_FILTER;
    }
    private static final int _POSIX_TRACE_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_INHERIT -1
     * }
     */
    public static int _POSIX_TRACE_INHERIT() {
        return _POSIX_TRACE_INHERIT;
    }
    private static final int _POSIX_TRACE_LOG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_LOG -1
     * }
     */
    public static int _POSIX_TRACE_LOG() {
        return _POSIX_TRACE_LOG;
    }
    private static final int _POSIX_TYPED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TYPED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_TYPED_MEMORY_OBJECTS() {
        return _POSIX_TYPED_MEMORY_OBJECTS;
    }
    private static final int _POSIX_V7_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LPBIG_OFFBIG -1
     * }
     */
    public static int _POSIX_V7_LPBIG_OFFBIG() {
        return _POSIX_V7_LPBIG_OFFBIG;
    }
    private static final int _POSIX_V6_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LPBIG_OFFBIG -1
     * }
     */
    public static int _POSIX_V6_LPBIG_OFFBIG() {
        return _POSIX_V6_LPBIG_OFFBIG;
    }
    private static final int _XBS5_LPBIG_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LPBIG_OFFBIG -1
     * }
     */
    public static int _XBS5_LPBIG_OFFBIG() {
        return _XBS5_LPBIG_OFFBIG;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32_CFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFF32_CFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFF32_CFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFF32_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32_LDFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFF32_LDFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFF32_LDFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFF32_LDFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG_CFLAGS "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
     * }
     */
    public static MemorySegment __ILP32_OFFBIG_CFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFFBIG_CFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64");
        }
        return Holder.__ILP32_OFFBIG_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG_LDFLAGS "-m32"
     * }
     */
    public static MemorySegment __ILP32_OFFBIG_LDFLAGS() {
        class Holder {
            static final MemorySegment __ILP32_OFFBIG_LDFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m32");
        }
        return Holder.__ILP32_OFFBIG_LDFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64_CFLAGS "-m64"
     * }
     */
    public static MemorySegment __LP64_OFF64_CFLAGS() {
        class Holder {
            static final MemorySegment __LP64_OFF64_CFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m64");
        }
        return Holder.__LP64_OFF64_CFLAGS;
    }
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64_LDFLAGS "-m64"
     * }
     */
    public static MemorySegment __LP64_OFF64_LDFLAGS() {
        class Holder {
            static final MemorySegment __LP64_OFF64_LDFLAGS
                = NautyTraces.LIBRARY_ARENA.allocateFrom("-m64");
        }
        return Holder.__LP64_OFF64_LDFLAGS;
    }
    private static final int L_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define L_SET 0
     * }
     */
    public static int L_SET() {
        return L_SET;
    }
    private static final int L_INCR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define L_INCR 1
     * }
     */
    public static int L_INCR() {
        return L_INCR;
    }
    private static final int L_XTND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define L_XTND 2
     * }
     */
    public static int L_XTND() {
        return L_XTND;
    }
    private static final int _SC_PAGE_SIZE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGE_SIZE 30
     * }
     */
    public static int _SC_PAGE_SIZE() {
        return _SC_PAGE_SIZE;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 1
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS 4
     * }
     */
    public static int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS 5
     * }
     */
    public static int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS;
    }
    private static final int __WCLONE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCLONE 2147483648
     * }
     */
    public static int __WCLONE() {
        return __WCLONE;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int PTHREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int PTHREAD_DESTRUCTOR_ITERATIONS() {
        return PTHREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int SEM_VALUE_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SEM_VALUE_MAX 2147483647
     * }
     */
    public static int SEM_VALUE_MAX() {
        return SEM_VALUE_MAX;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final int BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_BASE_MAX 99
     * }
     */
    public static int BC_BASE_MAX() {
        return BC_BASE_MAX;
    }
    private static final int BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define BC_DIM_MAX 2048
     * }
     */
    public static int BC_DIM_MAX() {
        return BC_DIM_MAX;
    }
    private static final int BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_SCALE_MAX 99
     * }
     */
    public static int BC_SCALE_MAX() {
        return BC_SCALE_MAX;
    }
    private static final int BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define BC_STRING_MAX 1000
     * }
     */
    public static int BC_STRING_MAX() {
        return BC_STRING_MAX;
    }
    private static final int EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXPR_NEST_MAX 32
     * }
     */
    public static int EXPR_NEST_MAX() {
        return EXPR_NEST_MAX;
    }
    private static final int LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LINE_MAX 2048
     * }
     */
    public static int LINE_MAX() {
        return LINE_MAX;
    }
    private static final int RE_DUP_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RE_DUP_MAX 32767
     * }
     */
    public static int RE_DUP_MAX() {
        return RE_DUP_MAX;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define COUNTER_FMT "%llu"
     * }
     */
    public static MemorySegment COUNTER_FMT() {
        class Holder {
            static final MemorySegment COUNTER_FMT
                = NautyTraces.LIBRARY_ARENA.allocateFrom("%llu");
        }
        return Holder.COUNTER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define COUNTER_FMT_RAW "llu"
     * }
     */
    public static MemorySegment COUNTER_FMT_RAW() {
        class Holder {
            static final MemorySegment COUNTER_FMT_RAW
                = NautyTraces.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.COUNTER_FMT_RAW;
    }
    private static final int NAUTYVERSIONID = (int)29301L;
    /**
     * {@snippet lang=c :
     * #define NAUTYVERSIONID 29301
     * }
     */
    public static int NAUTYVERSIONID() {
        return NAUTYVERSIONID;
    }
    private static final int NAUTYREQUIRED = (int)29301L;
    /**
     * {@snippet lang=c :
     * #define NAUTYREQUIRED 29301
     * }
     */
    public static int NAUTYREQUIRED() {
        return NAUTYREQUIRED;
    }
    /**
     * {@snippet lang=c :
     * #define NAUTYVERSION "2.9.3 (64 bits)"
     * }
     */
    public static MemorySegment NAUTYVERSION() {
        class Holder {
            static final MemorySegment NAUTYVERSION
                = NautyTraces.LIBRARY_ARENA.allocateFrom("2.9.3 (64 bits)");
        }
        return Holder.NAUTYVERSION;
    }
    private static final long MSK3232 = -4294967296L;
    /**
     * {@snippet lang=c :
     * #define MSK3232 -4294967296
     * }
     */
    public static long MSK3232() {
        return MSK3232;
    }
    private static final long MSK1648 = -281474976710656L;
    /**
     * {@snippet lang=c :
     * #define MSK1648 -281474976710656
     * }
     */
    public static long MSK1648() {
        return MSK1648;
    }
    private static final long MSK0856 = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MSK0856 -72057594037927936
     * }
     */
    public static long MSK0856() {
        return MSK0856;
    }
    private static final long MSK1632 = 281470681743360L;
    /**
     * {@snippet lang=c :
     * #define MSK1632 281470681743360
     * }
     */
    public static long MSK1632() {
        return MSK1632;
    }
    private static final long MSK0840 = 280375465082880L;
    /**
     * {@snippet lang=c :
     * #define MSK0840 280375465082880
     * }
     */
    public static long MSK0840() {
        return MSK0840;
    }
    private static final long MSK1616 = 4294901760L;
    /**
     * {@snippet lang=c :
     * #define MSK1616 4294901760
     * }
     */
    public static long MSK1616() {
        return MSK1616;
    }
    private static final long MSK0824 = 4278190080L;
    /**
     * {@snippet lang=c :
     * #define MSK0824 4278190080
     * }
     */
    public static long MSK0824() {
        return MSK0824;
    }
    private static final long MSK0808 = 65280L;
    /**
     * {@snippet lang=c :
     * #define MSK0808 65280
     * }
     */
    public static long MSK0808() {
        return MSK0808;
    }
    private static final long MSK63C = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MSK63C 9223372036854775807
     * }
     */
    public static long MSK63C() {
        return MSK63C;
    }
    private static final long MSK31C = 2147483647L;
    /**
     * {@snippet lang=c :
     * #define MSK31C 2147483647
     * }
     */
    public static long MSK31C() {
        return MSK31C;
    }
    private static final long MSK15C = 32767L;
    /**
     * {@snippet lang=c :
     * #define MSK15C 32767
     * }
     */
    public static long MSK15C() {
        return MSK15C;
    }
    private static final long MSK64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MSK64 -1
     * }
     */
    public static long MSK64() {
        return MSK64;
    }
    private static final long MSK32 = 4294967295L;
    /**
     * {@snippet lang=c :
     * #define MSK32 4294967295
     * }
     */
    public static long MSK32() {
        return MSK32;
    }
    private static final long MSK16 = 65535L;
    /**
     * {@snippet lang=c :
     * #define MSK16 65535
     * }
     */
    public static long MSK16() {
        return MSK16;
    }
    private static final long MSK8 = 255L;
    /**
     * {@snippet lang=c :
     * #define MSK8 255
     * }
     */
    public static long MSK8() {
        return MSK8;
    }
    /**
     * {@snippet lang=c :
     * #define SETWORD_DEC_FORMAT "%lu"
     * }
     */
    public static MemorySegment SETWORD_DEC_FORMAT() {
        class Holder {
            static final MemorySegment SETWORD_DEC_FORMAT
                = NautyTraces.LIBRARY_ARENA.allocateFrom("%lu");
        }
        return Holder.SETWORD_DEC_FORMAT;
    }
    /**
     * {@snippet lang=c :
     * #define SETWORD_FORMAT "%016lx"
     * }
     */
    public static MemorySegment SETWORD_FORMAT() {
        class Holder {
            static final MemorySegment SETWORD_FORMAT
                = NautyTraces.LIBRARY_ARENA.allocateFrom("%016lx");
        }
        return Holder.SETWORD_FORMAT;
    }
    private static final long ALLBITS = -1L;
    /**
     * {@snippet lang=c :
     * #define ALLBITS -1
     * }
     */
    public static long ALLBITS() {
        return ALLBITS;
    }
    private static final MemorySegment NILFUNCTION = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILFUNCTION (void*) 0
     * }
     */
    public static MemorySegment NILFUNCTION() {
        return NILFUNCTION;
    }
    private static final MemorySegment NILSET = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILSET (void*) 0
     * }
     */
    public static MemorySegment NILSET() {
        return NILSET;
    }
    private static final MemorySegment NILGRAPH = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NILGRAPH (void*) 0
     * }
     */
    public static MemorySegment NILGRAPH() {
        return NILGRAPH;
    }
    /**
     * {@snippet lang=c :
     * #define SORTPROG "sort"
     * }
     */
    public static MemorySegment SORTPROG() {
        class Holder {
            static final MemorySegment SORTPROG
                = NautyTraces.LIBRARY_ARENA.allocateFrom("sort");
        }
        return Holder.SORTPROG;
    }
    /**
     * {@snippet lang=c :
     * #define SG_WEIGHT_FMT "%d"
     * }
     */
    public static MemorySegment SG_WEIGHT_FMT() {
        class Holder {
            static final MemorySegment SG_WEIGHT_FMT
                = NautyTraces.LIBRARY_ARENA.allocateFrom("%d");
        }
        return Holder.SG_WEIGHT_FMT;
    }
    private static final int SG_MINWEIGHT = (int)-2000000002L;
    /**
     * {@snippet lang=c :
     * #define SG_MINWEIGHT -2000000002
     * }
     */
    public static int SG_MINWEIGHT() {
        return SG_MINWEIGHT;
    }
}

